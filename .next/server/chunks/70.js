"use strict";exports.id=70,exports.ids=[70],exports.modules={4070:(e,t,r)=>{r.r(t),r.d(t,{InferenceSession:()=>P,TRACE:()=>U,TRACE_FUNC_BEGIN:()=>_,TRACE_FUNC_END:()=>I,Tensor:()=>L,default:()=>tt,env:()=>p,registerBackend:()=>s});var n={};r.r(n),r.d(n,{InferenceSession:()=>P,TRACE:()=>U,TRACE_FUNC_BEGIN:()=>_,TRACE_FUNC_END:()=>I,Tensor:()=>L,env:()=>p,registerBackend:()=>s});var o=r(8086);let a=new Map,i=[],s=(e,t,r)=>{if(t&&"function"==typeof t.init&&"function"==typeof t.createInferenceSessionHandler){let n=a.get(e);if(void 0===n)a.set(e,{backend:t,priority:r});else if(n.priority>r)return;else if(n.priority===r&&n.backend!==t)throw Error(`cannot register backend "${e}" using priority ${r}`);if(r>=0){let t=i.indexOf(e);-1!==t&&i.splice(t,1);for(let t=0;t<i.length;t++)if(a.get(i[t]).priority<=r){i.splice(t,0,e);return}i.push(e)}return}throw TypeError("not a valid backend")},l=async e=>{let t=a.get(e);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(e){return r||(t.error=`${e}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},u=async e=>{let t;let r=e.executionProviders||[],n=r.map(e=>"string"==typeof e?e:e.name),o=0===n.length?i:n,a=[],s=new Set;for(let e of o){let r=await l(e);"string"==typeof r?a.push({name:e,err:r}):(t||(t=r),t===r&&s.add(e))}if(!t)throw Error(`no available backend found. ERR: ${a.map(e=>`[${e.name}] ${e.err}`).join(", ")}`);for(let{name:e,err:t}of a)n.includes(e)&&console.warn(`removing requested execution provider "${e}" from session options because it is not available: ${t}`);let u=r.filter(e=>s.has("string"==typeof e?e:e.name));return[t,new Proxy(e,{get:(e,t)=>"executionProviders"===t?u:Reflect.get(e,t)})]},f="warning",d={wasm:{},webgl:{},webgpu:{},versions:{common:"1.21.0-dev.20250206-d981b153d3"},set logLevel(value){if(void 0===value)return;if("string"!=typeof value||-1===["verbose","info","warning","error","fatal"].indexOf(value))throw Error(`Unsupported logging level: ${value}`);f=value},get logLevel(){return f}};Object.defineProperty(d,"logLevel",{enumerable:!0});let p=d,c=(e,t)=>{let r="undefined"!=typeof document?document.createElement("canvas"):new OffscreenCanvas(1,1);r.width=e.dims[3],r.height=e.dims[2];let n=r.getContext("2d");if(null!=n){let o,a,i,s;t?.tensorLayout!==void 0&&"NHWC"===t.tensorLayout?(o=e.dims[2],a=e.dims[3]):(o=e.dims[3],a=e.dims[2]);let l=t?.format!==void 0?t.format:"RGB",u=t?.norm;void 0===u||void 0===u.mean?i=[255,255,255,255]:"number"==typeof u.mean?i=[u.mean,u.mean,u.mean,u.mean]:(i=[u.mean[0],u.mean[1],u.mean[2],0],void 0!==u.mean[3]&&(i[3]=u.mean[3])),void 0===u||void 0===u.bias?s=[0,0,0,0]:"number"==typeof u.bias?s=[u.bias,u.bias,u.bias,u.bias]:(s=[u.bias[0],u.bias[1],u.bias[2],0],void 0!==u.bias[3]&&(s[3]=u.bias[3]));let f=a*o,d=0,p=f,c=2*f,h=-1;"RGBA"===l?(d=0,p=f,c=2*f,h=3*f):"RGB"===l?(d=0,p=f,c=2*f):"RBG"===l&&(d=0,c=f,p=2*f);for(let t=0;t<a;t++)for(let r=0;r<o;r++){let o=(e.data[d++]-s[0])*i[0],a=(e.data[p++]-s[1])*i[1];n.fillStyle="rgba("+o+","+a+","+(e.data[c++]-s[2])*i[2]+","+(-1===h?255:(e.data[h++]-s[3])*i[3])+")",n.fillRect(r,t,1,1)}if("toDataURL"in r)return r.toDataURL();throw Error("toDataURL is not supported")}throw Error("Can not access image data")},h=(e,t)=>{let r;let n="undefined"!=typeof document?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");if(null!=n){let o,a,i,s,l;t?.tensorLayout!==void 0&&"NHWC"===t.tensorLayout?(o=e.dims[2],a=e.dims[1],i=e.dims[3]):(o=e.dims[3],a=e.dims[2],i=e.dims[1]);let u=void 0!==t&&void 0!==t.format?t.format:"RGB",f=t?.norm;void 0===f||void 0===f.mean?s=[255,255,255,255]:"number"==typeof f.mean?s=[f.mean,f.mean,f.mean,f.mean]:(s=[f.mean[0],f.mean[1],f.mean[2],255],void 0!==f.mean[3]&&(s[3]=f.mean[3])),void 0===f||void 0===f.bias?l=[0,0,0,0]:"number"==typeof f.bias?l=[f.bias,f.bias,f.bias,f.bias]:(l=[f.bias[0],f.bias[1],f.bias[2],0],void 0!==f.bias[3]&&(l[3]=f.bias[3]));let d=a*o;if(void 0!==t&&(void 0!==t.format&&4===i&&"RGBA"!==t.format||3===i&&"RGB"!==t.format&&"BGR"!==t.format))throw Error("Tensor format doesn't match input tensor dims");let p=0,c=1,h=2,m=3,y=0,g=d,w=2*d,b=-1;"RGBA"===u?(y=0,g=d,w=2*d,b=3*d):"RGB"===u?(y=0,g=d,w=2*d):"RBG"===u&&(y=0,w=d,g=2*d),r=n.createImageData(o,a);for(let t=0;t<a*o;p+=4,c+=4,h+=4,m+=4,t++)r.data[p]=(e.data[y++]-l[0])*s[0],r.data[c]=(e.data[g++]-l[1])*s[1],r.data[h]=(e.data[w++]-l[2])*s[2],r.data[m]=-1===b?255:(e.data[b++]-l[3])*s[3]}else throw Error("Can not access image data");return r},m=(e,t)=>{let r,n;if(void 0===e)throw Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw Error("NHWC Tensor layout is not supported yet");let{height:o,width:a}=t,i=t.norm??{mean:255,bias:0};r="number"==typeof i.mean?[i.mean,i.mean,i.mean,i.mean]:[i.mean[0],i.mean[1],i.mean[2],i.mean[3]??255],n="number"==typeof i.bias?[i.bias,i.bias,i.bias,i.bias]:[i.bias[0],i.bias[1],i.bias[2],i.bias[3]??0];let s=void 0!==t.format?t.format:"RGBA",l=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",u=o*a,f=new Float32Array("RGBA"===l?4*u:3*u),d=4,p=0,c=1,h=2,m=3,y=0,g=u,w=2*u,b=-1;"RGB"===s&&(d=3,p=0,c=1,h=2,m=-1),"RGBA"===l?b=3*u:"RBG"===l?(y=0,w=u,g=2*u):"BGR"===l&&(w=0,g=u,y=2*u);for(let t=0;t<u;t++,p+=d,h+=d,c+=d,m+=d)f[y++]=(e[p]+n[0])/r[0],f[g++]=(e[c]+n[1])/r[1],f[w++]=(e[h]+n[2])/r[2],-1!==b&&-1!==m&&(f[b++]=(e[m]+n[3])/r[3]);return"RGBA"===l?new x("float32",f,[1,4,o,a]):new x("float32",f,[1,3,o,a])},y=async(e,t)=>{let r;let n="undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement,o="undefined"!=typeof ImageData&&e instanceof ImageData,a="undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap,i="string"==typeof e,s=t??{},l=()=>{if("undefined"!=typeof document)return document.createElement("canvas");if("undefined"!=typeof OffscreenCanvas)return new OffscreenCanvas(1,1);throw Error("Canvas is not supported")},u=e=>"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement?e.getContext("2d"):e instanceof OffscreenCanvas?e.getContext("2d"):null;if(n){let n=l();n.width=e.width,n.height=e.height;let o=u(n);if(null!=o){let n=e.height,a=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(n=t.resizedHeight,a=t.resizedWidth),void 0!==t){if(s=t,void 0!==t.tensorFormat)throw Error("Image input config format must be RGBA for HTMLImageElement");s.tensorFormat="RGBA",s.height=n,s.width=a}else s.tensorFormat="RGBA",s.height=n,s.width=a;o.drawImage(e,0,0),r=o.getImageData(0,0,a,n).data}else throw Error("Can not access image data")}else if(o){let n,o;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(n=t.resizedHeight,o=t.resizedWidth):(n=e.height,o=e.width),void 0!==t&&(s=t),s.format="RGBA",s.height=n,s.width=o,void 0!==t){let t=l();t.width=o,t.height=n;let a=u(t);if(null!=a)a.putImageData(e,0,0),r=a.getImageData(0,0,o,n).data;else throw Error("Can not access image data")}else r=e.data}else if(a){if(void 0===t)throw Error("Please provide image config with format for Imagebitmap");let n=l();n.width=e.width,n.height=e.height;let o=u(n);if(null!=o){let t=e.height,n=e.width;return o.drawImage(e,0,0,n,t),r=o.getImageData(0,0,n,t).data,s.height=t,s.width=n,m(r,s)}throw Error("Can not access image data")}else if(i)return new Promise((t,r)=>{let n=l(),o=u(n);if(!e||!o)return r();let a=new Image;a.crossOrigin="Anonymous",a.src=e,a.onload=()=>{n.width=a.width,n.height=a.height,o.drawImage(a,0,0,n.width,n.height);let e=o.getImageData(0,0,n.width,n.height);s.height=n.height,s.width=n.width,t(m(e.data,s))}});else throw Error("Input data provided is not supported - aborted tensor creation");if(void 0!==r)return m(r,s);throw Error("Input data provided is not supported - aborted tensor creation")},g=(e,t)=>{let{width:r,height:n,download:o,dispose:a}=t;return new x({location:"texture",type:"float32",texture:e,dims:[1,n,r,4],download:o,dispose:a})},w=(e,t)=>{let{dataType:r,dims:n,download:o,dispose:a}=t;return new x({location:"gpu-buffer",type:r??"float32",gpuBuffer:e,dims:n,download:o,dispose:a})},b=(e,t)=>{let{dataType:r,dims:n,download:o,dispose:a}=t;return new x({location:"ml-tensor",type:r??"float32",mlTensor:e,dims:n,download:o,dispose:a})},v=(e,t,r)=>new x({location:"cpu-pinned",type:e,data:t,dims:r??[t.length]}),E=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),A=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),T=!1,C=()=>{if(!T){T=!0;let e="undefined"!=typeof BigInt64Array&&BigInt64Array.from,t="undefined"!=typeof BigUint64Array&&BigUint64Array.from,r="undefined"!=typeof Float16Array&&Float16Array.from;e&&(E.set("int64",BigInt64Array),A.set(BigInt64Array,"int64")),t&&(E.set("uint64",BigUint64Array),A.set(BigUint64Array,"uint64")),r?(E.set("float16",Float16Array),A.set(Float16Array,"float16")):E.set("float16",Uint16Array)}},O=e=>{let t=1;for(let r=0;r<e.length;r++){let n=e[r];if("number"!=typeof n||!Number.isSafeInteger(n))throw TypeError(`dims[${r}] must be an integer, got: ${n}`);if(n<0)throw RangeError(`dims[${r}] must be a non-negative integer, got: ${n}`);t*=n}return t},R=(e,t)=>{switch(e.location){case"cpu":return new x(e.type,e.data,t);case"cpu-pinned":return new x({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new x({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new x({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new x({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw Error(`tensorReshape: tensor location ${e.location} is not supported`)}};class x{constructor(e,t,r){let n,o;if(C(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,n=e.type,o=e.dims,e.location){case"cpu-pinned":{let t=E.get(n);if(!t)throw TypeError(`unsupported type "${n}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==n)throw TypeError(`unsupported type "${n}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==n&&"float16"!==n&&"int32"!==n&&"int64"!==n&&"uint32"!==n&&"uint8"!==n&&"bool"!==n&&"uint4"!==n&&"int4"!==n)throw TypeError(`unsupported type "${n}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;case"ml-tensor":if("float32"!==n&&"float16"!==n&&"int32"!==n&&"int64"!==n&&"uint32"!==n&&"uint64"!==n&&"int8"!==n&&"uint8"!==n&&"bool"!==n&&"uint4"!==n&&"int4"!==n)throw TypeError(`unsupported type "${n}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break;default:throw Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let a,i;if("string"==typeof e){if(n=e,i=r,"string"===e){if(!Array.isArray(t))throw TypeError("A string tensor's data must be a string array.");a=t}else{let r=E.get(e);if(void 0===r)throw TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e&&r===Uint16Array||"uint4"===e||"int4"===e)throw TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${r.name} as data.`);a="uint64"===e||"int64"===e?r.from(t,BigInt):r.from(t)}else if(t instanceof r)a=t;else if(t instanceof Uint8ClampedArray){if("uint8"===e)a=Uint8Array.from(t);else throw TypeError("A Uint8ClampedArray tensor's data must be type of uint8")}else throw TypeError(`A ${n} tensor's data must be type of ${r}`)}}else if(i=t,Array.isArray(e)){if(0===e.length)throw TypeError("Tensor type cannot be inferred from an empty array.");let t=typeof e[0];if("string"===t)n="string",a=e;else if("boolean"===t)n="bool",a=Uint8Array.from(e);else throw TypeError(`Invalid element type of data array: ${t}.`)}else if(e instanceof Uint8ClampedArray)n="uint8",a=Uint8Array.from(e);else{let t=A.get(e.constructor);if(void 0===t)throw TypeError(`Unsupported type for tensor data: ${e.constructor}.`);n=t,a=e}if(void 0===i)i=[a.length];else if(!Array.isArray(i))throw TypeError("A tensor's dims must be a number array");o=i,this.cpuData=a,this.dataLocation="cpu"}let a=O(o);if(this.cpuData&&a!==this.cpuData.length){if(("uint4"===n||"int4"===n)&&Math.ceil(a/2)===this.cpuData.length);else throw Error(`Tensor's size(${a}) does not match data length(${this.cpuData.length}).`)}this.type=n,this.dims=o,this.size=a}static async fromImage(e,t){return y(e,t)}static fromTexture(e,t){return g(e,t)}static fromGpuBuffer(e,t){return w(e,t)}static fromMLTensor(e,t){return b(e,t)}static fromPinnedBuffer(e,t,r){return v(e,t,r)}toDataURL(e){return c(this,e)}toImageData(e){return h(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":if(!this.downloader)throw Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw Error("Cannot reshape a tensor that owns GPU resource.");return R(this,e)}}let L=x,U=(e,t)=>{(void 0===d.trace?!!d.wasm.trace:!!d.trace)&&console.timeStamp(`${e}::ORT::${t}`)},$=(e,t)=>{let r=Error().stack?.split(/\r\n|\r|\n/g)||[],n=!1;for(let o=0;o<r.length;o++){if(n&&!r[o].includes("TRACE_FUNC")){let n=`FUNC_${e}::${r[o].trim().split(" ")[1]}`;t&&(n+=`::${t}`),U("CPU",n);return}r[o].includes("TRACE_FUNC")&&(n=!0)}},_=e=>{(void 0===d.trace?!!d.wasm.trace:!!d.trace)&&$("BEGIN",e)},I=e=>{(void 0===d.trace?!!d.wasm.trace:!!d.trace)&&$("END",e)};class B{constructor(e){this.handler=e}async run(e,t,r){_();let n={},o={};if("object"!=typeof e||null===e||e instanceof L||Array.isArray(e))throw TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if("object"==typeof t){if(null===t)throw TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof L)throw TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw TypeError("'fetches' cannot be an empty array.");for(let e of(a=!1,t)){if("string"!=typeof e)throw TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw RangeError(`'fetches' contains invalid output name: ${e}.`);n[e]=null}if("object"==typeof r&&null!==r)o=r;else if(void 0!==r)throw TypeError("'options' must be an object.")}else{let e=!1,i=Object.getOwnPropertyNames(t);for(let r of this.outputNames)if(-1!==i.indexOf(r)){let o=t[r];(null===o||o instanceof L)&&(e=!0,a=!1,n[r]=o)}if(e){if("object"==typeof r&&null!==r)o=r;else if(void 0!==r)throw TypeError("'options' must be an object.")}else o=t}}else if(void 0!==t)throw TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of this.inputNames)if(void 0===e[t])throw Error(`input '${t}' is missing in 'feeds'.`);if(a)for(let e of this.outputNames)n[e]=null;let i=await this.handler.run(e,n,o),s={};for(let e in i)if(Object.hasOwnProperty.call(i,e)){let t=i[e];t instanceof L?s[e]=t:s[e]=new L(t.type,t.data,t.dims)}return I(),s}async release(){return this.handler.dispose()}static async create(e,t,r,n){let o;_();let a={};if("string"==typeof e){if(o=e,"object"==typeof t&&null!==t)a=t;else if(void 0!==t)throw TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(o=e,"object"==typeof t&&null!==t)a=t;else if(void 0!==t)throw TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&e instanceof SharedArrayBuffer){let i=0,s=e.byteLength;if("object"==typeof t&&null!==t)a=t;else if("number"==typeof t){if(!Number.isSafeInteger(i=t))throw RangeError("'byteOffset' must be an integer.");if(i<0||i>=e.byteLength)throw RangeError(`'byteOffset' is out of range [0, ${e.byteLength}).`);if(s=e.byteLength-i,"number"==typeof r){if(!Number.isSafeInteger(s=r))throw RangeError("'byteLength' must be an integer.");if(s<=0||i+s>e.byteLength)throw RangeError(`'byteLength' is out of range (0, ${e.byteLength-i}].`);if("object"==typeof n&&null!==n)a=n;else if(void 0!==n)throw TypeError("'options' must be an object.")}else if(void 0!==r)throw TypeError("'byteLength' must be a number.")}else if(void 0!==t)throw TypeError("'options' must be an object.");o=new Uint8Array(e,i,s)}else throw TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[i,s]=await u(a),l=await i.createInferenceSessionHandler(o,s);return I(),new B(l)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}let P=B,N=(0,o.createRequire)("file:///Users/dtorredo/Code/Re-Thing/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs");var S,D,G,j,F,k,M,W,V,z,H,q,Z,J,K,Q,X,Y,ee,et,er,en,eo,ea,ei,es,el,eu,ef,ed,ep,ec,eh,em,ey,eg,ew,eb,ev,eE,eA,eT,eC,eO,eR,ex,eL,eU,e$,e_,eI,eB,eP,eN,eS,eD,eG,ej,eF,ek,eM,eW=Object.defineProperty,eV=Object.getOwnPropertyDescriptor,ez=Object.getOwnPropertyNames,eH=Object.prototype.hasOwnProperty,eq=(e=>"u">typeof N?N:"u">typeof Proxy?new Proxy(e,{get:(e,t)=>("u">typeof N?N:e)[t]}):e)(function(e){if("u">typeof N)return N.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),eZ=(e,t)=>()=>(e&&(t=e(e=0)),t),eJ=eZ(()=>{S=!!("u">typeof process&&process.versions&&process.versions.node)}),eK=eZ(()=>{eJ(),D=S||typeof location>"u"?void 0:location.origin,G=(()=>{if(!S)return"file:///Users/dtorredo/Code/Re-Thing/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs".startsWith("file:")?new URL(new r.U(r(4687)).href,D).href:"file:///Users/dtorredo/Code/Re-Thing/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs"})(),j=()=>{if(G&&!G.startsWith("blob:"))return G.substring(0,G.lastIndexOf("/")+1)},F=(e,t)=>{try{let r=t??G;return(r?new URL(e,r):new URL(e)).origin===D}catch{return!1}},k=(e,t)=>{let r=t??G;try{return(r?new URL(e,r):new URL(e)).href}catch{return}},M=(e,t)=>`${t??"./"}${e}`,W=async e=>{let t=await (await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(t)},V=async e=>(await import(e)).default,z=void 0,H=async(e,t,r)=>{if(!e&&!t&&z&&G&&F(G))return[void 0,z];{let n="ort-wasm-simd-threaded.mjs",o=e??k(n,t),a=!S&&r&&o&&!F(o,t),i=a?await W(o):o??M(n,t);return[a?i:void 0,await V(i)]}}}),eQ=eZ(()=>{eK(),Z=!1,J=!1,K=!1,Q=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return"u">typeof MessageChannel&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},X=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Y=async e=>{if(Z)return Promise.resolve();if(J)throw Error("multiple calls to 'initializeWebAssembly()' detected.");if(K)throw Error("previous call to 'initializeWebAssembly()' failed.");J=!0;let t=e.initTimeout,r=e.numThreads;if(!X())throw Error("WebAssembly SIMD is not supported in the current environment.");let n=Q();r>1&&!n&&("u">typeof self&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+r+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=r=1);let o=e.wasmPaths,a="string"==typeof o?o:void 0,i=o?.mjs,s=i?.href??i,l=o?.wasm,u=l?.href??l,f=e.wasmBinary,[d,p]=await H(s,a,r>1),c=!1,h=[];if(t>0&&h.push(new Promise(e=>{setTimeout(()=>{c=!0,e()},t)})),h.push(new Promise((e,t)=>{let n={numThreads:r};if(f)n.wasmBinary=f;else if(u||a)n.locateFile=e=>u??a+e;else if(s&&0!==s.indexOf("blob:"))n.locateFile=e=>new URL(e,s).href;else if(d){let e=j();e&&(n.locateFile=t=>e+t)}p(n).then(t=>{J=!1,Z=!0,q=t,e(),d&&URL.revokeObjectURL(d)},e=>{J=!1,K=!0,t(e)})})),await Promise.race(h),c)throw Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},ee=()=>{if(Z&&q)return q;throw Error("WebAssembly is not initialized yet.")}}),eX=eZ(()=>{eQ(),et=(e,t)=>{let r=ee(),n=r.lengthBytesUTF8(e)+1,o=r._malloc(n);return r.stringToUTF8(e,o,n),t.push(o),o},er=(e,t,r,n)=>{if("object"==typeof e&&null!==e){if(r.has(e))throw Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([e,o])=>{let a=t?t+e:e;if("object"==typeof o)er(o,a+".",r,n);else if("string"==typeof o||"number"==typeof o)n(a,o.toString());else if("boolean"==typeof o)n(a,o?"1":"0");else throw Error(`Can't handle extra config type: ${typeof o}`)})},en=e=>{let t=ee(),r=t.stackSave();try{let r=t.PTR_SIZE,n=t.stackAlloc(2*r);t._OrtGetLastError(n,n+r);let o=Number(t.getValue(n,4===r?"i32":"i64")),a=t.getValue(n+r,"*"),i=a?t.UTF8ToString(a):"";throw Error(`${e} ERROR_CODE: ${o}, ERROR_MESSAGE: ${i}`)}finally{t.stackRestore(r)}}}),eY=eZ(()=>{eQ(),eX(),eo=e=>{let t=ee(),r=0,n=[],o=e||{};try{if(e?.logSeverityLevel===void 0)o.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)o.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(o.terminate=!1);let a=0;return e?.tag!==void 0&&(a=et(e.tag,n)),r=t._OrtCreateRunOptions(o.logSeverityLevel,o.logVerbosityLevel,!!o.terminate,a),0===r&&en("Can't create run options."),e?.extra!==void 0&&er(e.extra,"",new WeakSet,(e,o)=>{let a=et(e,n),i=et(o,n);0!==t._OrtAddRunConfigEntry(r,a,i)&&en(`Can't set a run config entry: ${e} - ${o}.`)}),[r,n]}catch(e){throw 0!==r&&t._OrtReleaseRunOptions(r),n.forEach(e=>t._free(e)),e}}}),e0=eZ(()=>{eQ(),eX(),ea=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw Error(`unsupported graph optimization level: ${e}`)}},ei=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw Error(`unsupported execution mode: ${e}`)}},es=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(e=>("string"==typeof e?e:e.name)==="webgpu")&&(e.enableMemPattern=!1)},el=(e,t,r)=>{for(let n of t){let t="string"==typeof n?n:n.name;switch(t){case"webnn":if(t="WEBNN","string"!=typeof n){let t=n?.deviceType;if(t){let n=et("deviceType",r),o=et(t,r);0!==ee()._OrtAddSessionConfigEntry(e,n,o)&&en(`Can't set a session config entry: 'deviceType' - ${t}.`)}}break;case"webgpu":if(t="JS","string"!=typeof n&&n?.preferredLayout){if("NCHW"!==n.preferredLayout&&"NHWC"!==n.preferredLayout)throw Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${n.preferredLayout}`);let t=et("preferredLayout",r),o=et(n.preferredLayout,r);0!==ee()._OrtAddSessionConfigEntry(e,t,o)&&en(`Can't set a session config entry: 'preferredLayout' - ${n.preferredLayout}.`)}break;case"wasm":case"cpu":continue;default:throw Error(`not supported execution provider: ${t}`)}let o=et(t,r);0!==ee()._OrtAppendExecutionProvider(e,o)&&en(`Can't append execution provider: ${t}.`)}},eu=e=>{let t=ee(),r=0,n=[],o=e||{};es(o);try{let e=ea(o.graphOptimizationLevel??"all"),a=ei(o.executionMode??"sequential"),i="string"==typeof o.logId?et(o.logId,n):0,s=o.logSeverityLevel??2;if(!Number.isInteger(s)||s<0||s>4)throw Error(`log serverity level is not valid: ${s}`);let l=o.logVerbosityLevel??0;if(!Number.isInteger(l)||l<0||l>4)throw Error(`log verbosity level is not valid: ${l}`);let u="string"==typeof o.optimizedModelFilePath?et(o.optimizedModelFilePath,n):0;if(r=t._OrtCreateSessionOptions(e,!!o.enableCpuMemArena,!!o.enableMemPattern,a,!!o.enableProfiling,0,i,s,l,u),0===r&&en("Can't create session options."),o.executionProviders&&el(r,o.executionProviders,n),void 0!==o.enableGraphCapture){if("boolean"!=typeof o.enableGraphCapture)throw Error(`enableGraphCapture must be a boolean value: ${o.enableGraphCapture}`);let e=et("enableGraphCapture",n),a=et(o.enableGraphCapture.toString(),n);0!==t._OrtAddSessionConfigEntry(r,e,a)&&en(`Can't set a session config entry: 'enableGraphCapture' - ${o.enableGraphCapture}.`)}if(o.freeDimensionOverrides)for(let[e,a]of Object.entries(o.freeDimensionOverrides)){if("string"!=typeof e)throw Error(`free dimension override name must be a string: ${e}`);if("number"!=typeof a||!Number.isInteger(a)||a<0)throw Error(`free dimension override value must be a non-negative integer: ${a}`);let o=et(e,n);0!==t._OrtAddFreeDimensionOverride(r,o,a)&&en(`Can't set a free dimension override: ${e} - ${a}.`)}return void 0!==o.extra&&er(o.extra,"",new WeakSet,(e,o)=>{let a=et(e,n),i=et(o,n);0!==t._OrtAddSessionConfigEntry(r,a,i)&&en(`Can't set a session config entry: ${e} - ${o}.`)}),[r,n]}catch(e){throw 0!==r&&0!==t._OrtReleaseSessionOptions(r)&&en("Can't release session options."),n.forEach(e=>t._free(e)),e}}}),e1=eZ(()=>{ef=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw Error(`unsupported data type: ${e}`)}},ed=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw Error(`unsupported data type: ${e}`)}},ep=(e,t)=>{let r=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],n="number"==typeof t?t:t.reduce((e,t)=>e*t,1);return r>0?Math.ceil(n*r):void 0},ec=e=>{switch(e){case"float16":return"u">typeof Float16Array&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw Error(`unsupported type: ${e}`)}},eh=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw Error(`unsupported logging level: ${e}`)}},em=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,ey=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint64"===e||"int8"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,eg=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw Error(`unsupported data location: ${e}`)}}}),e2=eZ(()=>{eJ(),ew=async e=>{if("string"!=typeof e)return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e);if(S)try{let{readFile:t}=eq("node:fs/promises");return new Uint8Array(await t(e))}catch(t){if("ERR_FS_FILE_TOO_LARGE"===t.code){let{createReadStream:t}=eq("node:fs"),r=t(e),n=[];for await(let e of r)n.push(e);return new Uint8Array(Buffer.concat(n))}throw t}else{let t=await fetch(e);if(!t.ok)throw Error(`failed to load external data file: ${e}`);let r=t.headers.get("Content-Length"),n=r?parseInt(r,10):0;if(n<0x40000000)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw Error(`failed to load external data file: ${e}, no response body.`);let r=t.body.getReader(),o;try{o=new ArrayBuffer(n)}catch(e){if(e instanceof RangeError){let e=Math.ceil(n/65536);o=new WebAssembly.Memory({initial:e,maximum:e}).buffer}else throw e}let a=0;for(;;){let{done:e,value:t}=await r.read();if(e)break;let n=t.byteLength;new Uint8Array(o,a,n).set(t),a+=n}return new Uint8Array(o,0,n)}}}}),e3=eZ(()=>{eY(),e0(),e1(),eQ(),eX(),e2(),eb=(e,t)=>{0!==ee()._OrtInit(e,t)&&en("Can't initialize onnxruntime.")},ev=async e=>{eb(e.wasm.numThreads,eh(e.logLevel))},eE=async(e,t)=>{},eA=new Map,eT=e=>{let t=ee(),r=t.stackSave();try{let r=t.PTR_SIZE,n=t.stackAlloc(2*r);0!==t._OrtGetInputOutputCount(e,n,n+r)&&en("Can't get session input/output count.");let o=4===r?"i32":"i64";return[Number(t.getValue(n,o)),Number(t.getValue(n+r,o))]}finally{t.stackRestore(r)}},eC=e=>{let t=ee(),r=t._malloc(e.byteLength);if(0===r)throw Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},eO=async(e,t)=>{let r,n,o=ee();Array.isArray(e)?[r,n]=e:e.buffer===o.HEAPU8.buffer?[r,n]=[e.byteOffset,e.byteLength]:[r,n]=eC(e);let a=0,i=0,s=[],l=[],u=[];try{if([i,s]=eu(t),t?.externalData&&o.mountExternalData){let e=[];for(let r of t.externalData){let t="string"==typeof r?r:r.path;e.push(ew("string"==typeof r?r:r.data).then(e=>{o.mountExternalData(t,e)}))}await Promise.all(e)}for(let e of t?.executionProviders??[])if(("string"==typeof e?e:e.name)==="webnn"){if(o.shouldTransferToMLTensor=!1,"string"!=typeof e){let t=e?.context,r=e?.gpuDevice,n=e?.deviceType,a=e?.powerPreference;t?o.currentContext=t:r?o.currentContext=await o.jsepCreateMLContext(r):o.currentContext=await o.jsepCreateMLContext({deviceType:n,powerPreference:a})}else o.currentContext=await o.jsepCreateMLContext();break}a=await o._OrtCreateSession(r,n,i),0===a&&en("Can't create a session."),o.jsepOnCreateSession?.(),o.currentContext&&(o.jsepRegisterMLContext(a,o.currentContext),o.currentContext=void 0,o.shouldTransferToMLTensor=!0);let[e,f]=eT(a),d=!!t?.enableGraphCapture,p=[],c=[];for(let t=0;t<e;t++){let e=o._OrtGetInputName(a,t);0===e&&en("Can't get an input name."),l.push(e),p.push(o.UTF8ToString(e))}for(let e=0;e<f;e++){let t=o._OrtGetOutputName(a,e);0===t&&en("Can't get an output name."),u.push(t);let r=o.UTF8ToString(t);c.push(r)}return eA.set(a,[a,l,u,null,d,!1]),[a,p,c]}catch(e){throw l.forEach(e=>o._OrtFree(e)),u.forEach(e=>o._OrtFree(e)),0!==a&&0!==o._OrtReleaseSession(a)&&en("Can't release session."),e}finally{o._free(r),0!==i&&0!==o._OrtReleaseSessionOptions(i)&&en("Can't release session options."),s.forEach(e=>o._free(e)),o.unmountExternalData?.()}},eR=e=>{let t=ee(),r=eA.get(e);if(!r)throw Error(`cannot release session. invalid session id: ${e}`);let[n,o,a,i,s]=r;i&&(s&&0!==t._OrtClearBoundOutputs(i.handle)&&en("Can't clear bound outputs."),0!==t._OrtReleaseBinding(i.handle)&&en("Can't release IO binding.")),t.jsepOnReleaseSession?.(e),o.forEach(e=>t._OrtFree(e)),a.forEach(e=>t._OrtFree(e)),0!==t._OrtReleaseSession(n)&&en("Can't release session."),eA.delete(e)},ex=(e,t,r,n,o,a=!1)=>{if(!e){t.push(0);return}let i=ee(),s=i.PTR_SIZE,l=e[0],u=e[1],f=e[3],d,p;if("string"===l&&("gpu-buffer"===f||"ml-tensor"===f))throw Error("String tensor is not supported on GPU.");if(a&&"gpu-buffer"!==f)throw Error(`External buffer must be provided for input/output index ${o} when enableGraphCapture is true.`);if("gpu-buffer"===f){let t=e[2].gpuBuffer;p=ep(ef(l),u);let r=i.jsepRegisterBuffer;if(!r)throw Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');d=r(n,o,t,p)}else if("ml-tensor"===f){let t=e[2].mlTensor;p=ep(ef(l),u);let r=i.jsepRegisterMLTensor;if(!r)throw Error('Tensor location "ml-tensor" is not supported without using WebNN.');d=r(t,ef(l),u)}else{let t=e[2];if(Array.isArray(t)){p=s*t.length,d=i._malloc(p),r.push(d);for(let e=0;e<t.length;e++){if("string"!=typeof t[e])throw TypeError(`tensor data at index ${e} is not a string`);i.setValue(d+e*s,et(t[e],r),"*")}}else p=t.byteLength,d=i._malloc(p),r.push(d),i.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,p),d)}let c=i.stackSave(),h=i.stackAlloc(4*u.length);try{u.forEach((e,t)=>i.setValue(h+t*s,e,4===s?"i32":"i64"));let e=i._OrtCreateTensor(ef(l),d,p,h,u.length,eg(f));0===e&&en(`Can't create tensor for input/output. session=${n}, index=${o}.`),t.push(e)}finally{i.stackRestore(c)}},eL=async(e,t,r,n,o,a)=>{let i=ee(),s=i.PTR_SIZE,l=eA.get(e);if(!l)throw Error(`cannot run inference. invalid session id: ${e}`);let u=l[0],f=l[1],d=l[2],p=l[3],c=l[4],h=(l[5],t.length),m=n.length,y=0,g=[],w=[],b=[],v=[],E=i.stackSave(),A=i.stackAlloc(h*s),T=i.stackAlloc(h*s),C=i.stackAlloc(m*s),O=i.stackAlloc(m*s);try{let l;i.jsepOnRunStart?.(u),[y,g]=eo(a);for(let n=0;n<h;n++)ex(r[n],w,v,e,t[n],c);for(let t=0;t<m;t++)ex(o[t],b,v,e,h+n[t],c);for(let e=0;e<h;e++)i.setValue(A+e*s,w[e],"*"),i.setValue(T+e*s,f[t[e]],"*");for(let e=0;e<m;e++)i.setValue(C+e*s,b[e],"*"),i.setValue(O+e*s,d[n[e]],"*");l=await i._OrtRun(u,T,A,h,O,m,C,y),0!==l&&en("failed to call OrtRun().");let E=[];for(let e=0;e<m;e++){let t=Number(i.getValue(C+e*s,"*"));if(t===b[e]){E.push(o[e]);continue}let r=i.stackSave(),a=i.stackAlloc(4*s),l=!1,u,f=0;try{0!==i._OrtGetTensorData(t,a,a+s,a+2*s,a+3*s)&&en(`Can't access output tensor data on index ${e}.`);let r=4===s?"i32":"i64",o=Number(i.getValue(a,r));f=i.getValue(a+s,"*");let d=i.getValue(a+2*s,"*"),c=Number(i.getValue(a+3*s,r)),h=[];for(let e=0;e<c;e++)h.push(Number(i.getValue(d+e*s,r)));0!==i._OrtFree(d)&&en("Can't free memory for tensor dims.");let m=h.reduce((e,t)=>e*t,1);u=ed(o);let y=p?.outputPreferredLocations[n[e]];if("string"===u){if("gpu-buffer"===y||"ml-tensor"===y)throw Error("String tensor is not supported on GPU.");let e=[];for(let t=0;t<m;t++){let r=i.getValue(f+t*s,"*"),n=i.getValue(f+(t+1)*s,"*"),o=t===m-1?void 0:n-r;e.push(i.UTF8ToString(r,o))}E.push([u,h,e,"cpu"])}else if("gpu-buffer"===y&&m>0){let e=i.jsepGetBuffer;if(!e)throw Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let r=e(f),n=ep(o,m);if(void 0===n||!em(u))throw Error(`Unsupported data type: ${u}`);l=!0,E.push([u,h,{gpuBuffer:r,download:i.jsepCreateDownloader(r,n,u),dispose:()=>{0!==i._OrtReleaseTensor(t)&&en("Can't release tensor.")}},"gpu-buffer"])}else if("ml-tensor"===y&&m>0){let e=i.jsepEnsureTensor;if(!e)throw Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(void 0===ep(o,m)||!ey(u))throw Error(`Unsupported data type: ${u}`);let r=await e(f,o,h,!1);l=!0,E.push([u,h,{mlTensor:r,download:i.jsepCreateMLTensorDownloader(f,u),dispose:()=>{i.jsepReleaseTensorId(f),i._OrtReleaseTensor(t)}},"ml-tensor"])}else{let e=new(ec(u))(m);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(i.HEAPU8.subarray(f,f+e.byteLength)),E.push([u,h,e,"cpu"])}}finally{i.stackRestore(r),"string"===u&&f&&i._free(f),l||i._OrtReleaseTensor(t)}}return p&&!c&&(0!==i._OrtClearBoundOutputs(p.handle)&&en("Can't clear bound outputs."),eA.set(e,[u,f,d,p,c,!1])),E}finally{i.stackRestore(E),w.forEach(e=>i._OrtReleaseTensor(e)),b.forEach(e=>i._OrtReleaseTensor(e)),v.forEach(e=>i._free(e)),0!==y&&i._OrtReleaseRunOptions(y),g.forEach(e=>i._free(e))}},eU=e=>{let t=ee(),r=eA.get(e);if(!r)throw Error("invalid session id");let n=r[0],o=t._OrtEndProfiling(n);0===o&&en("Can't get an profile file name."),t._OrtFree(o)}}),e6=eZ(()=>{e3(),eQ(),eK(),e$=!1,e_=!1,eI=!1,eB=async()=>{if(!e_){if(e$)throw Error("multiple calls to 'initWasm()' detected.");if(eI)throw Error("previous call to 'initWasm()' failed.");e$=!0;try{await Y(p.wasm),await ev(p),e_=!0}catch(e){throw eI=!0,e}finally{e$=!1}}},eP=async e=>{await eE(p,e)},eN=async e=>eC(e),eS=async(e,t)=>eO(e,t),eD=async e=>{eR(e)},eG=async(e,t,r,n,o,a)=>eL(e,t,r,n,o,a),ej=async e=>{eU(e)}}),e4=eZ(()=>{e6(),e1(),eJ(),e2(),eF=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw Error(`invalid data location: ${e.location} for ${t()}`)}},ek=e=>{switch(e[3]){case"cpu":return new L(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!em(t))throw Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:r,download:n,dispose:o}=e[2];return L.fromGpuBuffer(r,{dataType:t,dims:e[1],download:n,dispose:o})}case"ml-tensor":{let t=e[0];if(!ey(t))throw Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:r,download:n,dispose:o}=e[2];return L.fromMLTensor(r,{dataType:t,dims:e[1],download:n,dispose:o})}default:throw Error(`invalid data location: ${e[3]}`)}},eM=class{async fetchModelAndCopyToWasmMemory(e){return eN(await ew(e))}async loadModel(e,t){let r;_(),r="string"==typeof e?S?await ew(e):await this.fetchModelAndCopyToWasmMemory(e):e,[this.sessionId,this.inputNames,this.outputNames]=await eS(r,t),I()}async dispose(){return eD(this.sessionId)}async run(e,t,r){_();let n=[],o=[];Object.entries(e).forEach(e=>{let t=e[0],r=e[1],a=this.inputNames.indexOf(t);if(-1===a)throw Error(`invalid input '${t}'`);n.push(r),o.push(a)});let a=[],i=[];Object.entries(t).forEach(e=>{let t=e[0],r=e[1],n=this.outputNames.indexOf(t);if(-1===n)throw Error(`invalid output '${t}'`);a.push(r),i.push(n)});let s=n.map((e,t)=>eF(e,()=>`input "${this.inputNames[o[t]]}"`)),l=a.map((e,t)=>e?eF(e,()=>`output "${this.outputNames[i[t]]}"`):null),u=await eG(this.sessionId,o,s,i,l,r),f={};for(let e=0;e<u.length;e++)f[this.outputNames[i[e]]]=a[e]??ek(u[e]);return I(),f}startProfiling(){}endProfiling(){ej(this.sessionId)}}}),e8={};((e,t)=>{for(var r in t)eW(e,r,{get:t[r],enumerable:!0})})(e8,{OnnxruntimeWebAssemblyBackend:()=>e9,initializeFlags:()=>e5,wasmBackend:()=>e7});var e5,e9,e7,te=eZ(()=>{e6(),e4(),e5=()=>{if(("number"!=typeof p.wasm.initTimeout||p.wasm.initTimeout<0)&&(p.wasm.initTimeout=0),!1===p.wasm.simd&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),"boolean"!=typeof p.wasm.proxy&&(p.wasm.proxy=!1),"boolean"!=typeof p.wasm.trace&&(p.wasm.trace=!1),"number"!=typeof p.wasm.numThreads||!Number.isInteger(p.wasm.numThreads)||p.wasm.numThreads<=0){if("u">typeof self&&!self.crossOriginIsolated)p.wasm.numThreads=1;else{let e=typeof navigator>"u"?eq("node:os").cpus().length:navigator.hardwareConcurrency;p.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}}},e7=new(e9=class{async init(e){e5(),await eB(),await eP(e)}async createInferenceSessionHandler(e,t){let r=new eM;return await r.loadModel(e,t),Promise.resolve(r)}})}),tt=n;{let e=(te(),((e,t,r,n)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let o of ez(t))eH.call(e,o)||o===r||eW(e,o,{get:()=>t[o],enumerable:!(n=eV(t,o))||n.enumerable});return e})(eW({},"__esModule",{value:!0}),e8)).wasmBackend;s("cpu",e,10),s("wasm",e,10)}Object.defineProperty(p.versions,"web",{value:"1.21.0-dev.20250206-d981b153d3",enumerable:!0})},4687:(e,t,r)=>{e.exports=r.p+"static/media/ort.node.min.2826e051.mjs"}};