module.exports = {

"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/backend-impl.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({
    "registerBackend": (()=>registerBackend),
    "resolveBackendAndExecutionProviders": (()=>resolveBackendAndExecutionProviders)
});
const backends = new Map();
const backendsSortedByPriority = [];
const registerBackend = (name, backend, priority)=>{
    if (backend && typeof backend.init === 'function' && typeof backend.createInferenceSessionHandler === 'function') {
        const currentBackend = backends.get(name);
        if (currentBackend === undefined) {
            backends.set(name, {
                backend,
                priority
            });
        } else if (currentBackend.priority > priority) {
            // same name is already registered with a higher priority. skip registeration.
            return;
        } else if (currentBackend.priority === priority) {
            if (currentBackend.backend !== backend) {
                throw new Error(`cannot register backend "${name}" using priority ${priority}`);
            }
        }
        if (priority >= 0) {
            const i = backendsSortedByPriority.indexOf(name);
            if (i !== -1) {
                backendsSortedByPriority.splice(i, 1);
            }
            for(let i = 0; i < backendsSortedByPriority.length; i++){
                if (backends.get(backendsSortedByPriority[i]).priority <= priority) {
                    backendsSortedByPriority.splice(i, 0, name);
                    return;
                }
            }
            backendsSortedByPriority.push(name);
        }
        return;
    }
    throw new TypeError('not a valid backend');
};
/**
 * Try to resolve and initialize a backend.
 *
 * @param backendName - the name of the backend.
 * @returns the backend instance if resolved and initialized successfully, or an error message if failed.
 */ const tryResolveAndInitializeBackend = async (backendName)=>{
    const backendInfo = backends.get(backendName);
    if (!backendInfo) {
        return 'backend not found.';
    }
    if (backendInfo.initialized) {
        return backendInfo.backend;
    } else if (backendInfo.aborted) {
        return backendInfo.error;
    } else {
        const isInitializing = !!backendInfo.initPromise;
        try {
            if (!isInitializing) {
                backendInfo.initPromise = backendInfo.backend.init(backendName);
            }
            await backendInfo.initPromise;
            backendInfo.initialized = true;
            return backendInfo.backend;
        } catch (e) {
            if (!isInitializing) {
                backendInfo.error = `${e}`;
                backendInfo.aborted = true;
            }
            return backendInfo.error;
        } finally{
            delete backendInfo.initPromise;
        }
    }
};
const resolveBackendAndExecutionProviders = async (options)=>{
    // extract backend hints from session options
    const eps = options.executionProviders || [];
    const backendHints = eps.map((i)=>typeof i === 'string' ? i : i.name);
    const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
    // try to resolve and initialize all requested backends
    let backend;
    const errors = [];
    const availableBackendNames = new Set();
    for (const backendName of backendNames){
        const resolveResult = await tryResolveAndInitializeBackend(backendName);
        if (typeof resolveResult === 'string') {
            errors.push({
                name: backendName,
                err: resolveResult
            });
        } else {
            if (!backend) {
                backend = resolveResult;
            }
            if (backend === resolveResult) {
                availableBackendNames.add(backendName);
            }
        }
    }
    // if no backend is available, throw error.
    if (!backend) {
        throw new Error(`no available backend found. ERR: ${errors.map((e)=>`[${e.name}] ${e.err}`).join(', ')}`);
    }
    // for each explicitly requested backend, if it's not available, output warning message.
    for (const { name, err } of errors){
        if (backendHints.includes(name)) {
            // eslint-disable-next-line no-console
            console.warn(`removing requested execution provider "${name}" from session options because it is not available: ${err}`);
        }
    }
    const filteredEps = eps.filter((i)=>availableBackendNames.has(typeof i === 'string' ? i : i.name));
    return [
        backend,
        new Proxy(options, {
            get: (target, prop)=>{
                if (prop === 'executionProviders') {
                    return filteredEps;
                }
                return Reflect.get(target, prop);
            }
        })
    ];
}; //# sourceMappingURL=backend-impl.js.map
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/backend.js [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({});
;
 //# sourceMappingURL=backend.js.map
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/backend.js [app-ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/backend-impl.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/backend.js [app-ssr] (ecmascript) <locals>");
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/version.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// This file is generated by /js/scripts/update-version.ts
// Do not modify file content manually.
__turbopack_context__.s({
    "version": (()=>version)
});
const version = '1.21.0-dev.20250206-d981b153d3'; //# sourceMappingURL=version.js.map
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/env-impl.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({
    "env": (()=>env)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$version$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/version.js [app-ssr] (ecmascript)");
;
let logLevelValue = 'warning';
const env = {
    wasm: {},
    webgl: {},
    webgpu: {},
    versions: {
        common: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$version$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["version"]
    },
    set logLevel (value){
        if (value === undefined) {
            return;
        }
        if (typeof value !== 'string' || [
            'verbose',
            'info',
            'warning',
            'error',
            'fatal'
        ].indexOf(value) === -1) {
            throw new Error(`Unsupported logging level: ${value}`);
        }
        logLevelValue = value;
    },
    get logLevel () {
        return logLevelValue;
    }
};
// set property 'logLevel' so that they can be correctly transferred to worker by `postMessage()`.
Object.defineProperty(env, 'logLevel', {
    enumerable: true
}); //# sourceMappingURL=env-impl.js.map
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/env.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({
    "env": (()=>env)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/env-impl.js [app-ssr] (ecmascript)");
;
const env = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"]; //# sourceMappingURL=env.js.map
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * implementation of Tensor.toDataURL()
 */ __turbopack_context__.s({
    "tensorToDataURL": (()=>tensorToDataURL),
    "tensorToImageData": (()=>tensorToImageData)
});
const tensorToDataURL = (tensor, options)=>{
    const canvas = typeof document !== 'undefined' ? document.createElement('canvas') : new OffscreenCanvas(1, 1);
    canvas.width = tensor.dims[3];
    canvas.height = tensor.dims[2];
    const pixels2DContext = canvas.getContext('2d');
    if (pixels2DContext != null) {
        // Default values for height and width & format
        let width;
        let height;
        if (options?.tensorLayout !== undefined && options.tensorLayout === 'NHWC') {
            width = tensor.dims[2];
            height = tensor.dims[3];
        } else {
            // Default layout is NCWH
            width = tensor.dims[3];
            height = tensor.dims[2];
        }
        const inputformat = options?.format !== undefined ? options.format : 'RGB';
        const norm = options?.norm;
        let normMean;
        let normBias;
        if (norm === undefined || norm.mean === undefined) {
            normMean = [
                255,
                255,
                255,
                255
            ];
        } else {
            if (typeof norm.mean === 'number') {
                normMean = [
                    norm.mean,
                    norm.mean,
                    norm.mean,
                    norm.mean
                ];
            } else {
                normMean = [
                    norm.mean[0],
                    norm.mean[1],
                    norm.mean[2],
                    0
                ];
                if (norm.mean[3] !== undefined) {
                    normMean[3] = norm.mean[3];
                }
            }
        }
        if (norm === undefined || norm.bias === undefined) {
            normBias = [
                0,
                0,
                0,
                0
            ];
        } else {
            if (typeof norm.bias === 'number') {
                normBias = [
                    norm.bias,
                    norm.bias,
                    norm.bias,
                    norm.bias
                ];
            } else {
                normBias = [
                    norm.bias[0],
                    norm.bias[1],
                    norm.bias[2],
                    0
                ];
                if (norm.bias[3] !== undefined) {
                    normBias[3] = norm.bias[3];
                }
            }
        }
        const stride = height * width;
        // Default pointer assignments
        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
        // Updating the pointer assignments based on the input image format
        if (inputformat === 'RGBA') {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
            aTensorPointer = stride * 3;
        } else if (inputformat === 'RGB') {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
        } else if (inputformat === 'RBG') {
            rTensorPointer = 0;
            bTensorPointer = stride;
            gTensorPointer = stride * 2;
        }
        for(let i = 0; i < height; i++){
            for(let j = 0; j < width; j++){
                const R = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0]; // R value
                const G = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1]; // G value
                const B = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2]; // B value
                const A = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3]; // A value
                // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
                pixels2DContext.fillStyle = 'rgba(' + R + ',' + G + ',' + B + ',' + A + ')';
                pixels2DContext.fillRect(j, i, 1, 1);
            }
        }
        if ('toDataURL' in canvas) {
            return canvas.toDataURL();
        } else {
            throw new Error('toDataURL is not supported');
        }
    } else {
        throw new Error('Can not access image data');
    }
};
const tensorToImageData = (tensor, options)=>{
    const pixels2DContext = typeof document !== 'undefined' ? document.createElement('canvas').getContext('2d') : new OffscreenCanvas(1, 1).getContext('2d');
    let image;
    if (pixels2DContext != null) {
        // Default values for height and width & format
        let width;
        let height;
        let channels;
        if (options?.tensorLayout !== undefined && options.tensorLayout === 'NHWC') {
            width = tensor.dims[2];
            height = tensor.dims[1];
            channels = tensor.dims[3];
        } else {
            // Default layout is NCWH
            width = tensor.dims[3];
            height = tensor.dims[2];
            channels = tensor.dims[1];
        }
        const inputformat = options !== undefined ? options.format !== undefined ? options.format : 'RGB' : 'RGB';
        const norm = options?.norm;
        let normMean;
        let normBias;
        if (norm === undefined || norm.mean === undefined) {
            normMean = [
                255,
                255,
                255,
                255
            ];
        } else {
            if (typeof norm.mean === 'number') {
                normMean = [
                    norm.mean,
                    norm.mean,
                    norm.mean,
                    norm.mean
                ];
            } else {
                normMean = [
                    norm.mean[0],
                    norm.mean[1],
                    norm.mean[2],
                    255
                ];
                if (norm.mean[3] !== undefined) {
                    normMean[3] = norm.mean[3];
                }
            }
        }
        if (norm === undefined || norm.bias === undefined) {
            normBias = [
                0,
                0,
                0,
                0
            ];
        } else {
            if (typeof norm.bias === 'number') {
                normBias = [
                    norm.bias,
                    norm.bias,
                    norm.bias,
                    norm.bias
                ];
            } else {
                normBias = [
                    norm.bias[0],
                    norm.bias[1],
                    norm.bias[2],
                    0
                ];
                if (norm.bias[3] !== undefined) {
                    normBias[3] = norm.bias[3];
                }
            }
        }
        const stride = height * width;
        if (options !== undefined) {
            if (options.format !== undefined && channels === 4 && options.format !== 'RGBA' || channels === 3 && options.format !== 'RGB' && options.format !== 'BGR') {
                throw new Error("Tensor format doesn't match input tensor dims");
            }
        }
        // Default pointer assignments
        const step = 4;
        let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
        // Updating the pointer assignments based on the input image format
        if (inputformat === 'RGBA') {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
            aTensorPointer = stride * 3;
        } else if (inputformat === 'RGB') {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
        } else if (inputformat === 'RBG') {
            rTensorPointer = 0;
            bTensorPointer = stride;
            gTensorPointer = stride * 2;
        }
        image = pixels2DContext.createImageData(width, height);
        for(let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++){
            image.data[rImagePointer] = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0]; // R value
            image.data[gImagePointer] = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1]; // G value
            image.data[bImagePointer] = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2]; // B value
            image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3]; // A value
        }
    } else {
        throw new Error('Can not access image data');
    }
    return image;
}; //# sourceMappingURL=tensor-conversion-impl.js.map
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({
    "bufferToTensor": (()=>bufferToTensor),
    "tensorFromGpuBuffer": (()=>tensorFromGpuBuffer),
    "tensorFromImage": (()=>tensorFromImage),
    "tensorFromMLTensor": (()=>tensorFromMLTensor),
    "tensorFromPinnedBuffer": (()=>tensorFromPinnedBuffer),
    "tensorFromTexture": (()=>tensorFromTexture)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor-impl.js [app-ssr] (ecmascript)");
;
const bufferToTensor = (buffer, options)=>{
    if (buffer === undefined) {
        throw new Error('Image buffer must be defined');
    }
    if (options.height === undefined || options.width === undefined) {
        throw new Error('Image height and width must be defined');
    }
    if (options.tensorLayout === 'NHWC') {
        throw new Error('NHWC Tensor layout is not supported yet');
    }
    const { height, width } = options;
    const norm = options.norm ?? {
        mean: 255,
        bias: 0
    };
    let normMean;
    let normBias;
    if (typeof norm.mean === 'number') {
        normMean = [
            norm.mean,
            norm.mean,
            norm.mean,
            norm.mean
        ];
    } else {
        normMean = [
            norm.mean[0],
            norm.mean[1],
            norm.mean[2],
            norm.mean[3] ?? 255
        ];
    }
    if (typeof norm.bias === 'number') {
        normBias = [
            norm.bias,
            norm.bias,
            norm.bias,
            norm.bias
        ];
    } else {
        normBias = [
            norm.bias[0],
            norm.bias[1],
            norm.bias[2],
            norm.bias[3] ?? 0
        ];
    }
    const inputformat = options.format !== undefined ? options.format : 'RGBA';
    // default value is RGBA since imagedata and HTMLImageElement uses it
    const outputformat = options.tensorFormat !== undefined ? options.tensorFormat !== undefined ? options.tensorFormat : 'RGB' : 'RGB';
    const stride = height * width;
    const float32Data = outputformat === 'RGBA' ? new Float32Array(stride * 4) : new Float32Array(stride * 3);
    // Default pointer assignments
    let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
    let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
    // Updating the pointer assignments based on the input image format
    if (inputformat === 'RGB') {
        step = 3;
        rImagePointer = 0;
        gImagePointer = 1;
        bImagePointer = 2;
        aImagePointer = -1;
    }
    // Updating the pointer assignments based on the output tensor format
    if (outputformat === 'RGBA') {
        aTensorPointer = stride * 3;
    } else if (outputformat === 'RBG') {
        rTensorPointer = 0;
        bTensorPointer = stride;
        gTensorPointer = stride * 2;
    } else if (outputformat === 'BGR') {
        bTensorPointer = 0;
        gTensorPointer = stride;
        rTensorPointer = stride * 2;
    }
    for(let i = 0; i < stride; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step){
        float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias[0]) / normMean[0];
        float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias[1]) / normMean[1];
        float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias[2]) / normMean[2];
        if (aTensorPointer !== -1 && aImagePointer !== -1) {
            float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias[3]) / normMean[3];
        }
    }
    // Float32Array -> ort.Tensor
    const outputTensor = outputformat === 'RGBA' ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]('float32', float32Data, [
        1,
        4,
        height,
        width
    ]) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]('float32', float32Data, [
        1,
        3,
        height,
        width
    ]);
    return outputTensor;
};
const tensorFromImage = async (image, options)=>{
    // checking the type of image object
    const isHTMLImageEle = typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement;
    const isImageDataEle = typeof ImageData !== 'undefined' && image instanceof ImageData;
    const isImageBitmap = typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap;
    const isString = typeof image === 'string';
    let data;
    let bufferToTensorOptions = options ?? {};
    const createCanvas = ()=>{
        if (typeof document !== 'undefined') {
            return document.createElement('canvas');
        } else if (typeof OffscreenCanvas !== 'undefined') {
            return new OffscreenCanvas(1, 1);
        } else {
            throw new Error('Canvas is not supported');
        }
    };
    const createCanvasContext = (canvas)=>{
        if (typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement) {
            return canvas.getContext('2d');
        } else if (canvas instanceof OffscreenCanvas) {
            return canvas.getContext('2d');
        } else {
            return null;
        }
    };
    // filling and checking image configuration options
    if (isHTMLImageEle) {
        // HTMLImageElement - image object - format is RGBA by default
        const canvas = createCanvas();
        canvas.width = image.width;
        canvas.height = image.height;
        const pixels2DContext = createCanvasContext(canvas);
        if (pixels2DContext != null) {
            let height = image.height;
            let width = image.width;
            if (options !== undefined && options.resizedHeight !== undefined && options.resizedWidth !== undefined) {
                height = options.resizedHeight;
                width = options.resizedWidth;
            }
            if (options !== undefined) {
                bufferToTensorOptions = options;
                if (options.tensorFormat !== undefined) {
                    throw new Error('Image input config format must be RGBA for HTMLImageElement');
                } else {
                    bufferToTensorOptions.tensorFormat = 'RGBA';
                }
                bufferToTensorOptions.height = height;
                bufferToTensorOptions.width = width;
            } else {
                bufferToTensorOptions.tensorFormat = 'RGBA';
                bufferToTensorOptions.height = height;
                bufferToTensorOptions.width = width;
            }
            pixels2DContext.drawImage(image, 0, 0);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
        } else {
            throw new Error('Can not access image data');
        }
    } else if (isImageDataEle) {
        let height;
        let width;
        if (options !== undefined && options.resizedWidth !== undefined && options.resizedHeight !== undefined) {
            height = options.resizedHeight;
            width = options.resizedWidth;
        } else {
            height = image.height;
            width = image.width;
        }
        if (options !== undefined) {
            bufferToTensorOptions = options;
        }
        bufferToTensorOptions.format = 'RGBA';
        bufferToTensorOptions.height = height;
        bufferToTensorOptions.width = width;
        if (options !== undefined) {
            const tempCanvas = createCanvas();
            tempCanvas.width = width;
            tempCanvas.height = height;
            const pixels2DContext = createCanvasContext(tempCanvas);
            if (pixels2DContext != null) {
                pixels2DContext.putImageData(image, 0, 0);
                data = pixels2DContext.getImageData(0, 0, width, height).data;
            } else {
                throw new Error('Can not access image data');
            }
        } else {
            data = image.data;
        }
    } else if (isImageBitmap) {
        // ImageBitmap - image object - format must be provided by user
        if (options === undefined) {
            throw new Error('Please provide image config with format for Imagebitmap');
        }
        const canvas = createCanvas();
        canvas.width = image.width;
        canvas.height = image.height;
        const pixels2DContext = createCanvasContext(canvas);
        if (pixels2DContext != null) {
            const height = image.height;
            const width = image.width;
            pixels2DContext.drawImage(image, 0, 0, width, height);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
            bufferToTensorOptions.height = height;
            bufferToTensorOptions.width = width;
            return bufferToTensor(data, bufferToTensorOptions);
        } else {
            throw new Error('Can not access image data');
        }
    } else if (isString) {
        return new Promise((resolve, reject)=>{
            const canvas = createCanvas();
            const context = createCanvasContext(canvas);
            if (!image || !context) {
                return reject();
            }
            const newImage = new Image();
            newImage.crossOrigin = 'Anonymous';
            newImage.src = image;
            newImage.onload = ()=>{
                canvas.width = newImage.width;
                canvas.height = newImage.height;
                context.drawImage(newImage, 0, 0, canvas.width, canvas.height);
                const img = context.getImageData(0, 0, canvas.width, canvas.height);
                bufferToTensorOptions.height = canvas.height;
                bufferToTensorOptions.width = canvas.width;
                resolve(bufferToTensor(img.data, bufferToTensorOptions));
            };
        });
    } else {
        throw new Error('Input data provided is not supported - aborted tensor creation');
    }
    if (data !== undefined) {
        return bufferToTensor(data, bufferToTensorOptions);
    } else {
        throw new Error('Input data provided is not supported - aborted tensor creation');
    }
};
const tensorFromTexture = (texture, options)=>{
    const { width, height, download, dispose } = options;
    // Always assume RGBAF32. TODO: support different texture format
    const dims = [
        1,
        height,
        width,
        4
    ];
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]({
        location: 'texture',
        type: 'float32',
        texture,
        dims,
        download,
        dispose
    });
};
const tensorFromGpuBuffer = (gpuBuffer, options)=>{
    const { dataType, dims, download, dispose } = options;
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]({
        location: 'gpu-buffer',
        type: dataType ?? 'float32',
        gpuBuffer,
        dims,
        download,
        dispose
    });
};
const tensorFromMLTensor = (mlTensor, options)=>{
    const { dataType, dims, download, dispose } = options;
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]({
        location: 'ml-tensor',
        type: dataType ?? 'float32',
        mlTensor,
        dims,
        download,
        dispose
    });
};
const tensorFromPinnedBuffer = (type, buffer, dims)=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]({
        location: 'cpu-pinned',
        type,
        data: buffer,
        dims: dims ?? [
            buffer.length
        ]
    }); //# sourceMappingURL=tensor-factory-impl.js.map
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.
__turbopack_context__.s({
    "NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP": (()=>NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP),
    "NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP": (()=>NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP),
    "checkTypedArray": (()=>checkTypedArray)
});
const NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map([
    [
        'float32',
        Float32Array
    ],
    [
        'uint8',
        Uint8Array
    ],
    [
        'int8',
        Int8Array
    ],
    [
        'uint16',
        Uint16Array
    ],
    [
        'int16',
        Int16Array
    ],
    [
        'int32',
        Int32Array
    ],
    [
        'bool',
        Uint8Array
    ],
    [
        'float64',
        Float64Array
    ],
    [
        'uint32',
        Uint32Array
    ],
    [
        'int4',
        Uint8Array
    ],
    [
        'uint4',
        Uint8Array
    ]
]);
const NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map([
    [
        Float32Array,
        'float32'
    ],
    [
        Uint8Array,
        'uint8'
    ],
    [
        Int8Array,
        'int8'
    ],
    [
        Uint16Array,
        'uint16'
    ],
    [
        Int16Array,
        'int16'
    ],
    [
        Int32Array,
        'int32'
    ],
    [
        Float64Array,
        'float64'
    ],
    [
        Uint32Array,
        'uint32'
    ]
]);
// the following code allows delaying execution of BigInt/Float16Array checking. This allows lazy initialization for
// NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP and NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP, which allows BigInt/Float16Array
// polyfill if available.
let isTypedArrayChecked = false;
const checkTypedArray = ()=>{
    if (!isTypedArrayChecked) {
        isTypedArrayChecked = true;
        const isBigInt64ArrayAvailable = typeof BigInt64Array !== 'undefined' && BigInt64Array.from;
        const isBigUint64ArrayAvailable = typeof BigUint64Array !== 'undefined' && BigUint64Array.from;
        const isFloat16ArrayAvailable = typeof Float16Array !== 'undefined' && Float16Array.from;
        if (isBigInt64ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('int64', BigInt64Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, 'int64');
        }
        if (isBigUint64ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('uint64', BigUint64Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, 'uint64');
        }
        if (isFloat16ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('float16', Float16Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(Float16Array, 'float16');
        } else {
            // if Float16Array is not available, use 'Uint16Array' to store the data.
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('float16', Uint16Array);
        }
    }
}; //# sourceMappingURL=tensor-impl-type-mapping.js.map
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({
    "calculateSize": (()=>calculateSize),
    "tensorReshape": (()=>tensorReshape)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor-impl.js [app-ssr] (ecmascript)");
;
const calculateSize = (dims)=>{
    let size = 1;
    for(let i = 0; i < dims.length; i++){
        const dim = dims[i];
        if (typeof dim !== 'number' || !Number.isSafeInteger(dim)) {
            throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
        }
        if (dim < 0) {
            throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
        }
        size *= dim;
    }
    return size;
};
const tensorReshape = (tensor, dims)=>{
    switch(tensor.location){
        case 'cpu':
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"](tensor.type, tensor.data, dims);
        case 'cpu-pinned':
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]({
                location: 'cpu-pinned',
                data: tensor.data,
                type: tensor.type,
                dims
            });
        case 'texture':
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]({
                location: 'texture',
                texture: tensor.texture,
                type: tensor.type,
                dims
            });
        case 'gpu-buffer':
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]({
                location: 'gpu-buffer',
                gpuBuffer: tensor.gpuBuffer,
                type: tensor.type,
                dims
            });
        case 'ml-tensor':
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]({
                location: 'ml-tensor',
                mlTensor: tensor.mlTensor,
                type: tensor.type,
                dims
            });
        default:
            throw new Error(`tensorReshape: tensor location ${tensor.location} is not supported`);
    }
}; //# sourceMappingURL=tensor-utils-impl.js.map
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor-impl.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({
    "Tensor": (()=>Tensor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$conversion$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$factory$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2d$type$2d$mapping$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$utils$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js [app-ssr] (ecmascript)");
;
;
;
;
class Tensor {
    /**
     * implementation.
     */ constructor(arg0, arg1, arg2){
        // perform one-time check for BigInt/Float16Array support
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2d$type$2d$mapping$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["checkTypedArray"])();
        let type;
        let dims;
        if (typeof arg0 === 'object' && 'location' in arg0) {
            //
            // constructing tensor from specific location
            //
            this.dataLocation = arg0.location;
            type = arg0.type;
            dims = arg0.dims;
            switch(arg0.location){
                case 'cpu-pinned':
                    {
                        const expectedTypedArrayConstructor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2d$type$2d$mapping$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP"].get(type);
                        if (!expectedTypedArrayConstructor) {
                            throw new TypeError(`unsupported type "${type}" to create tensor from pinned buffer`);
                        }
                        if (!(arg0.data instanceof expectedTypedArrayConstructor)) {
                            throw new TypeError(`buffer should be of type ${expectedTypedArrayConstructor.name}`);
                        }
                        this.cpuData = arg0.data;
                        break;
                    }
                case 'texture':
                    {
                        if (type !== 'float32') {
                            throw new TypeError(`unsupported type "${type}" to create tensor from texture`);
                        }
                        this.gpuTextureData = arg0.texture;
                        this.downloader = arg0.download;
                        this.disposer = arg0.dispose;
                        break;
                    }
                case 'gpu-buffer':
                    {
                        if (type !== 'float32' && type !== 'float16' && type !== 'int32' && type !== 'int64' && type !== 'uint32' && type !== 'uint8' && type !== 'bool' && type !== 'uint4' && type !== 'int4') {
                            throw new TypeError(`unsupported type "${type}" to create tensor from gpu buffer`);
                        }
                        this.gpuBufferData = arg0.gpuBuffer;
                        this.downloader = arg0.download;
                        this.disposer = arg0.dispose;
                        break;
                    }
                case 'ml-tensor':
                    {
                        if (type !== 'float32' && type !== 'float16' && type !== 'int32' && type !== 'int64' && type !== 'uint32' && type !== 'uint64' && type !== 'int8' && type !== 'uint8' && type !== 'bool' && type !== 'uint4' && type !== 'int4') {
                            throw new TypeError(`unsupported type "${type}" to create tensor from MLTensor`);
                        }
                        this.mlTensorData = arg0.mlTensor;
                        this.downloader = arg0.download;
                        this.disposer = arg0.dispose;
                        break;
                    }
                default:
                    throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);
            }
        } else {
            //
            // constructing tensor of location 'cpu'
            //
            let data;
            let maybeDims;
            // check whether arg0 is type or data
            if (typeof arg0 === 'string') {
                //
                // Override: constructor(type, data, ...)
                //
                type = arg0;
                maybeDims = arg2;
                if (arg0 === 'string') {
                    // string tensor
                    if (!Array.isArray(arg1)) {
                        throw new TypeError("A string tensor's data must be a string array.");
                    }
                    // we don't check whether every element in the array is string; this is too slow. we assume it's correct and
                    // error will be populated at inference
                    data = arg1;
                } else {
                    // numeric tensor
                    const typedArrayConstructor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2d$type$2d$mapping$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP"].get(arg0);
                    if (typedArrayConstructor === undefined) {
                        throw new TypeError(`Unsupported tensor type: ${arg0}.`);
                    }
                    if (Array.isArray(arg1)) {
                        if (arg0 === 'float16' && typedArrayConstructor === Uint16Array || arg0 === 'uint4' || arg0 === 'int4') {
                            // - 'float16':
                            //   When no Float16Array polyfill is used, we cannot create 'float16' tensor from number array.
                            //
                            //   Throw error here because when user try to use number array as data,
                            //   e.g. new Tensor('float16', [1, 2, 3, 4], dims)), it will actually call
                            //   Uint16Array.from(arg1) which generates wrong data.
                            //
                            // - 'uint4' and 'int4':
                            //   Uint8Array.from(arg1) will generate wrong data for 'uint4' and 'int4' tensor.
                            //
                            throw new TypeError(`Creating a ${arg0} tensor from number array is not supported. Please use ${typedArrayConstructor.name} as data.`);
                        } else if (arg0 === 'uint64' || arg0 === 'int64') {
                            // use 'as any' here because:
                            // 1. TypeScript's check on type of 'Array.isArray()' does not work with readonly arrays.
                            // see https://github.com/microsoft/TypeScript/issues/17002
                            // 2. TypeScript's check on union type of '(BigInt64ArrayConstructor|BigUint64ArrayConstructor).from()'
                            // does not accept parameter mapFn.
                            // 3. parameters of 'SupportedTypedArrayConstructors.from()' does not match the requirement of the union
                            // type.
                            // assume 'arg1' is of type "readonly number[]|readonly bigint[]" here.
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            data = typedArrayConstructor.from(arg1, BigInt);
                        } else {
                            // assume 'arg1' is of type "readonly number[]" here.
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            data = typedArrayConstructor.from(arg1);
                        }
                    } else if (arg1 instanceof typedArrayConstructor) {
                        data = arg1;
                    } else if (arg1 instanceof Uint8ClampedArray) {
                        if (arg0 === 'uint8') {
                            data = Uint8Array.from(arg1);
                        } else {
                            throw new TypeError(`A Uint8ClampedArray tensor's data must be type of uint8`);
                        }
                    } else {
                        throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
                    }
                }
            } else {
                //
                // Override: constructor(data, ...)
                //
                maybeDims = arg1;
                if (Array.isArray(arg0)) {
                    // only boolean[] and string[] is supported
                    if (arg0.length === 0) {
                        throw new TypeError('Tensor type cannot be inferred from an empty array.');
                    }
                    const firstElementType = typeof arg0[0];
                    if (firstElementType === 'string') {
                        type = 'string';
                        data = arg0;
                    } else if (firstElementType === 'boolean') {
                        type = 'bool';
                        // 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is
                        // wrong type. We use 'as any' to make it happy.
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        data = Uint8Array.from(arg0);
                    } else {
                        throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
                    }
                } else if (arg0 instanceof Uint8ClampedArray) {
                    type = 'uint8';
                    data = Uint8Array.from(arg0);
                } else {
                    // get tensor type from TypedArray
                    const mappedType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2d$type$2d$mapping$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP"].get(arg0.constructor);
                    if (mappedType === undefined) {
                        throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
                    }
                    type = mappedType;
                    data = arg0;
                }
            }
            // type and data is processed, now processing dims
            if (maybeDims === undefined) {
                // assume 1-D tensor if dims omitted
                maybeDims = [
                    data.length
                ];
            } else if (!Array.isArray(maybeDims)) {
                throw new TypeError("A tensor's dims must be a number array");
            }
            dims = maybeDims;
            this.cpuData = data;
            this.dataLocation = 'cpu';
        }
        // perform check on dims
        const size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$utils$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["calculateSize"])(dims);
        // if data is on CPU, check whether data length matches tensor size
        if (this.cpuData && size !== this.cpuData.length) {
            if ((type === 'uint4' || type === 'int4') && Math.ceil(size / 2) === this.cpuData.length) {
            // for (u)int4, the data length is half of the tensor size. So we check this special case when size is odd.
            } else {
                throw new Error(`Tensor's size(${size}) does not match data length(${this.cpuData.length}).`);
            }
        }
        this.type = type;
        this.dims = dims;
        this.size = size;
    }
    // #endregion
    // #region factory
    static async fromImage(image, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$factory$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tensorFromImage"])(image, options);
    }
    static fromTexture(texture, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$factory$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tensorFromTexture"])(texture, options);
    }
    static fromGpuBuffer(gpuBuffer, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$factory$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tensorFromGpuBuffer"])(gpuBuffer, options);
    }
    static fromMLTensor(mlTensor, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$factory$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tensorFromMLTensor"])(mlTensor, options);
    }
    static fromPinnedBuffer(type, buffer, dims) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$factory$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tensorFromPinnedBuffer"])(type, buffer, dims);
    }
    // #endregion
    // #region conversions
    toDataURL(options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$conversion$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tensorToDataURL"])(this, options);
    }
    toImageData(options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$conversion$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tensorToImageData"])(this, options);
    }
    // #endregion
    // #region properties
    get data() {
        this.ensureValid();
        if (!this.cpuData) {
            throw new Error('The data is not on CPU. Use `getData()` to download GPU data to CPU, ' + 'or use `texture` or `gpuBuffer` property to access the GPU data directly.');
        }
        return this.cpuData;
    }
    get location() {
        return this.dataLocation;
    }
    get texture() {
        this.ensureValid();
        if (!this.gpuTextureData) {
            throw new Error('The data is not stored as a WebGL texture.');
        }
        return this.gpuTextureData;
    }
    get gpuBuffer() {
        this.ensureValid();
        if (!this.gpuBufferData) {
            throw new Error('The data is not stored as a WebGPU buffer.');
        }
        return this.gpuBufferData;
    }
    get mlTensor() {
        this.ensureValid();
        if (!this.mlTensorData) {
            throw new Error('The data is not stored as a WebNN MLTensor.');
        }
        return this.mlTensorData;
    }
    // #endregion
    // #region methods
    async getData(releaseData) {
        this.ensureValid();
        switch(this.dataLocation){
            case 'cpu':
            case 'cpu-pinned':
                return this.data;
            case 'texture':
            case 'gpu-buffer':
            case 'ml-tensor':
                {
                    if (!this.downloader) {
                        throw new Error('The current tensor is not created with a specified data downloader.');
                    }
                    if (this.isDownloading) {
                        throw new Error('The current tensor is being downloaded.');
                    }
                    try {
                        this.isDownloading = true;
                        const data = await this.downloader();
                        this.downloader = undefined;
                        this.dataLocation = 'cpu';
                        this.cpuData = data;
                        if (releaseData && this.disposer) {
                            this.disposer();
                            this.disposer = undefined;
                        }
                        return data;
                    } finally{
                        this.isDownloading = false;
                    }
                }
            default:
                throw new Error(`cannot get data from location: ${this.dataLocation}`);
        }
    }
    dispose() {
        if (this.isDownloading) {
            throw new Error('The current tensor is being downloaded.');
        }
        if (this.disposer) {
            this.disposer();
            this.disposer = undefined;
        }
        this.cpuData = undefined;
        this.gpuTextureData = undefined;
        this.gpuBufferData = undefined;
        this.mlTensorData = undefined;
        this.downloader = undefined;
        this.isDownloading = undefined;
        this.dataLocation = 'none';
    }
    // #endregion
    // #region tensor utilities
    ensureValid() {
        if (this.dataLocation === 'none') {
            throw new Error('The tensor is disposed.');
        }
    }
    reshape(dims) {
        this.ensureValid();
        if (this.downloader || this.disposer) {
            throw new Error('Cannot reshape a tensor that owns GPU resource.');
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$utils$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tensorReshape"])(this, dims);
    }
} //# sourceMappingURL=tensor-impl.js.map
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({
    "Tensor": (()=>Tensor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor-impl.js [app-ssr] (ecmascript)");
;
const Tensor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]; //# sourceMappingURL=tensor.js.map
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/trace.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({
    "TRACE": (()=>TRACE),
    "TRACE_FUNC_BEGIN": (()=>TRACE_FUNC_BEGIN),
    "TRACE_FUNC_END": (()=>TRACE_FUNC_END)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/env-impl.js [app-ssr] (ecmascript)");
;
const TRACE = (deviceType, label)=>{
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].trace === 'undefined' ? !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.trace : !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].trace) {
        return;
    }
    // eslint-disable-next-line no-console
    console.timeStamp(`${deviceType}::ORT::${label}`);
};
const TRACE_FUNC = (msg, extraMsg)=>{
    const stack = new Error().stack?.split(/\r\n|\r|\n/g) || [];
    let hasTraceFunc = false;
    for(let i = 0; i < stack.length; i++){
        if (hasTraceFunc && !stack[i].includes('TRACE_FUNC')) {
            let label = `FUNC_${msg}::${stack[i].trim().split(' ')[1]}`;
            if (extraMsg) {
                label += `::${extraMsg}`;
            }
            TRACE('CPU', label);
            return;
        }
        if (stack[i].includes('TRACE_FUNC')) {
            hasTraceFunc = true;
        }
    }
};
const TRACE_FUNC_BEGIN = (extraMsg)=>{
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].trace === 'undefined' ? !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.trace : !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].trace) {
        return;
    }
    TRACE_FUNC('BEGIN', extraMsg);
};
const TRACE_FUNC_END = (extraMsg)=>{
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].trace === 'undefined' ? !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.trace : !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].trace) {
        return;
    }
    TRACE_FUNC('END', extraMsg);
}; //# sourceMappingURL=trace.js.map
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/inference-session-impl.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({
    "InferenceSession": (()=>InferenceSession)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/backend-impl.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/trace.js [app-ssr] (ecmascript)");
;
;
;
class InferenceSession {
    constructor(handler){
        this.handler = handler;
    }
    async run(feeds, arg1, arg2) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_BEGIN"])();
        const fetches = {};
        let options = {};
        // check inputs
        if (typeof feeds !== 'object' || feeds === null || feeds instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"] || Array.isArray(feeds)) {
            throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
        }
        let isFetchesEmpty = true;
        // determine which override is being used
        if (typeof arg1 === 'object') {
            if (arg1 === null) {
                throw new TypeError('Unexpected argument[1]: cannot be null.');
            }
            if (arg1 instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]) {
                throw new TypeError("'fetches' cannot be a Tensor");
            }
            if (Array.isArray(arg1)) {
                if (arg1.length === 0) {
                    throw new TypeError("'fetches' cannot be an empty array.");
                }
                isFetchesEmpty = false;
                // output names
                for (const name of arg1){
                    if (typeof name !== 'string') {
                        throw new TypeError("'fetches' must be a string array or an object.");
                    }
                    if (this.outputNames.indexOf(name) === -1) {
                        throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
                    }
                    fetches[name] = null;
                }
                if (typeof arg2 === 'object' && arg2 !== null) {
                    options = arg2;
                } else if (typeof arg2 !== 'undefined') {
                    throw new TypeError("'options' must be an object.");
                }
            } else {
                // decide whether arg1 is fetches or options
                // if any output name is present and its value is valid OnnxValue, we consider it fetches
                let isFetches = false;
                const arg1Keys = Object.getOwnPropertyNames(arg1);
                for (const name of this.outputNames){
                    if (arg1Keys.indexOf(name) !== -1) {
                        const v = arg1[name];
                        if (v === null || v instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]) {
                            isFetches = true;
                            isFetchesEmpty = false;
                            fetches[name] = v;
                        }
                    }
                }
                if (isFetches) {
                    if (typeof arg2 === 'object' && arg2 !== null) {
                        options = arg2;
                    } else if (typeof arg2 !== 'undefined') {
                        throw new TypeError("'options' must be an object.");
                    }
                } else {
                    options = arg1;
                }
            }
        } else if (typeof arg1 !== 'undefined') {
            throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
        }
        // check if all inputs are in feed
        for (const name of this.inputNames){
            if (typeof feeds[name] === 'undefined') {
                throw new Error(`input '${name}' is missing in 'feeds'.`);
            }
        }
        // if no fetches is specified, we use the full output names list
        if (isFetchesEmpty) {
            for (const name of this.outputNames){
                fetches[name] = null;
            }
        }
        // feeds, fetches and options are prepared
        const results = await this.handler.run(feeds, fetches, options);
        const returnValue = {};
        for(const key in results){
            if (Object.hasOwnProperty.call(results, key)) {
                const result = results[key];
                if (result instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]) {
                    returnValue[key] = result;
                } else {
                    returnValue[key] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"](result.type, result.data, result.dims);
                }
            }
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_END"])();
        return returnValue;
    }
    async release() {
        return this.handler.dispose();
    }
    static async create(arg0, arg1, arg2, arg3) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_BEGIN"])();
        // either load from a file or buffer
        let filePathOrUint8Array;
        let options = {};
        if (typeof arg0 === 'string') {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === 'object' && arg1 !== null) {
                options = arg1;
            } else if (typeof arg1 !== 'undefined') {
                throw new TypeError("'options' must be an object.");
            }
        } else if (arg0 instanceof Uint8Array) {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === 'object' && arg1 !== null) {
                options = arg1;
            } else if (typeof arg1 !== 'undefined') {
                throw new TypeError("'options' must be an object.");
            }
        } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== 'undefined' && arg0 instanceof SharedArrayBuffer) {
            const buffer = arg0;
            let byteOffset = 0;
            let byteLength = arg0.byteLength;
            if (typeof arg1 === 'object' && arg1 !== null) {
                options = arg1;
            } else if (typeof arg1 === 'number') {
                byteOffset = arg1;
                if (!Number.isSafeInteger(byteOffset)) {
                    throw new RangeError("'byteOffset' must be an integer.");
                }
                if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
                    throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
                }
                byteLength = arg0.byteLength - byteOffset;
                if (typeof arg2 === 'number') {
                    byteLength = arg2;
                    if (!Number.isSafeInteger(byteLength)) {
                        throw new RangeError("'byteLength' must be an integer.");
                    }
                    if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
                        throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
                    }
                    if (typeof arg3 === 'object' && arg3 !== null) {
                        options = arg3;
                    } else if (typeof arg3 !== 'undefined') {
                        throw new TypeError("'options' must be an object.");
                    }
                } else if (typeof arg2 !== 'undefined') {
                    throw new TypeError("'byteLength' must be a number.");
                }
            } else if (typeof arg1 !== 'undefined') {
                throw new TypeError("'options' must be an object.");
            }
            filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
        } else {
            throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
        }
        // resolve backend, update session options with validated EPs, and create session handler
        const [backend, optionsWithValidatedEPs] = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["resolveBackendAndExecutionProviders"])(options);
        const handler = await backend.createInferenceSessionHandler(filePathOrUint8Array, optionsWithValidatedEPs);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_END"])();
        return new InferenceSession(handler);
    }
    startProfiling() {
        this.handler.startProfiling();
    }
    endProfiling() {
        this.handler.endProfiling();
    }
    get inputNames() {
        return this.handler.inputNames;
    }
    get outputNames() {
        return this.handler.outputNames;
    }
} //# sourceMappingURL=inference-session-impl.js.map
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/inference-session.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({
    "InferenceSession": (()=>InferenceSession)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$inference$2d$session$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/inference-session-impl.js [app-ssr] (ecmascript)");
;
const InferenceSession = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$inference$2d$session$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InferenceSession"]; //# sourceMappingURL=inference-session.js.map
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor-conversion.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({});
;
 //# sourceMappingURL=tensor-conversion.js.map
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor-factory.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({});
;
 //# sourceMappingURL=tensor-factory.js.map
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/onnx-model.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({});
;
 //# sourceMappingURL=onnx-model.js.map
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/onnx-value.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({});
;
 //# sourceMappingURL=onnx-value.js.map
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/index.js [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * # ONNX Runtime JavaScript API
 *
 * ONNX Runtime JavaScript API is a unified API for all JavaScript usages, including the following NPM packages:
 *
 * - [onnxruntime-node](https://www.npmjs.com/package/onnxruntime-node)
 * - [onnxruntime-web](https://www.npmjs.com/package/onnxruntime-web)
 * - [onnxruntime-react-native](https://www.npmjs.com/package/onnxruntime-react-native)
 *
 * See also:
 * - [Get Started](https://onnxruntime.ai/docs/get-started/with-javascript/)
 * - [Inference examples](https://github.com/microsoft/onnxruntime-inference-examples/tree/main/js)
 *
 * @packageDocumentation
 */ __turbopack_context__.s({});
;
;
;
;
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/index.js [app-ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/backend.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/env.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$inference$2d$session$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/inference-session.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$conversion$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor-conversion.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor-factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/trace.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$onnx$2d$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/onnx-model.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$onnx$2d$value$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/onnx-value.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/index.js [app-ssr] (ecmascript) <locals>");
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/backend.js [app-ssr] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "registerBackend": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["registerBackend"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/backend-impl.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/backend.js [app-ssr] (ecmascript) <locals>");
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/backend.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "registerBackend": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["registerBackend"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/backend.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/backend.js [app-ssr] (ecmascript) <exports>");
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/index.js [app-ssr] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "InferenceSession": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$inference$2d$session$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InferenceSession"]),
    "TRACE": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE"]),
    "TRACE_FUNC_BEGIN": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_BEGIN"]),
    "TRACE_FUNC_END": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_END"]),
    "Tensor": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]),
    "env": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"]),
    "registerBackend": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["registerBackend"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/backend.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/env.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$inference$2d$session$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/inference-session.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$conversion$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor-conversion.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor-factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/trace.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$onnx$2d$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/onnx-model.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$onnx$2d$value$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/onnx-value.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/index.js [app-ssr] (ecmascript) <locals>");
}}),
"[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "InferenceSession": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["InferenceSession"]),
    "TRACE": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["TRACE"]),
    "TRACE_FUNC_BEGIN": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["TRACE_FUNC_BEGIN"]),
    "TRACE_FUNC_END": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["TRACE_FUNC_END"]),
    "Tensor": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["Tensor"]),
    "env": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["env"]),
    "registerBackend": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["registerBackend"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/index.js [app-ssr] (ecmascript) <exports>");
}}),
"[project]/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs (static in ecmascript)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v("/_next/static/media/ort.node.min.fec81182.mjs");}}),
"[project]/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*!
 * ONNX Runtime Web v1.21.0-dev.20250206-d981b153d3
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */ __turbopack_context__.s({
    "default": (()=>Cr)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$module__$5b$external$5d$__$28$module$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/module [external] (module, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/env.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/tensor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/trace.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/backend-impl.js [app-ssr] (ecmascript)");
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs")}`;
    }
};
;
const require = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$module__$5b$external$5d$__$28$module$2c$__cjs$29$__["createRequire"])(__TURBOPACK__import$2e$meta__.url);
var ue = Object.defineProperty;
var pt = Object.getOwnPropertyDescriptor;
var mt = Object.getOwnPropertyNames;
var gt = Object.prototype.hasOwnProperty;
var ce = ((e)=>typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(e, {
        get: (t, n)=>(typeof require < "u" ? require : t)[n]
    }) : e)(function(e) {
    if (typeof require < "u") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + e + '" is not supported');
});
var A = (e, t)=>()=>(e && (t = e(e = 0)), t);
var bt = (e, t)=>{
    for(var n in t)ue(e, n, {
        get: t[n],
        enumerable: !0
    });
}, yt = (e, t, n, s)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let r of mt(t))!gt.call(e, r) && r !== n && ue(e, r, {
        get: ()=>t[r],
        enumerable: !(s = pt(t, r)) || s.enumerable
    });
    return e;
};
var wt = (e)=>yt(ue({}, "__esModule", {
        value: !0
    }), e);
var U, Q = A(()=>{
    "use strict";
    U = !!(typeof process < "u" && process.versions && process.versions.node);
});
var Pe, ht, k, xe, Te, St, Et, Ot, vt, Le, Ie, le = A(()=>{
    "use strict";
    Q();
    Pe = U || typeof location > "u" ? void 0 : location.origin, ht = ()=>{
        if (!U) return __TURBOPACK__import$2e$meta__.url?.startsWith("file:") ? new URL(new __turbopack_context__.U(__turbopack_context__.r("[project]/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs (static in ecmascript)")).href, Pe).href : __TURBOPACK__import$2e$meta__.url;
    }, k = ht(), xe = ()=>{
        if (k && !k.startsWith("blob:")) return k.substring(0, k.lastIndexOf("/") + 1);
    }, Te = (e, t)=>{
        try {
            let n = t ?? k;
            return (n ? new URL(e, n) : new URL(e)).origin === Pe;
        } catch  {
            return !1;
        }
    }, St = (e, t)=>{
        let n = t ?? k;
        try {
            return (n ? new URL(e, n) : new URL(e)).href;
        } catch  {
            return;
        }
    }, Et = (e, t)=>`${t ?? "./"}${e}`, Ot = async (e)=>{
        let n = await (await fetch(e, {
            credentials: "same-origin"
        })).blob();
        return URL.createObjectURL(n);
    }, vt = async (e)=>(await import(/*webpackIgnore:true*/ e)).default, Le = void 0, Ie = async (e, t, n)=>{
        if (!e && !t && Le && k && Te(k)) return [
            void 0,
            Le
        ];
        {
            let s = "ort-wasm-simd-threaded.mjs", r = e ?? St(s, t), i = !U && n && r && !Te(r, t), o = i ? await Ot(r) : r ?? Et(s, t);
            return [
                i ? o : void 0,
                await vt(o)
            ];
        }
    };
});
var fe, de, ee, _e, Tt, Lt, Ae, S, j = A(()=>{
    "use strict";
    le();
    de = !1, ee = !1, _e = !1, Tt = ()=>{
        if (typeof SharedArrayBuffer > "u") return !1;
        try {
            return typeof MessageChannel < "u" && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([
                0,
                97,
                115,
                109,
                1,
                0,
                0,
                0,
                1,
                4,
                1,
                96,
                0,
                0,
                3,
                2,
                1,
                0,
                5,
                4,
                1,
                3,
                1,
                1,
                10,
                11,
                1,
                9,
                0,
                65,
                0,
                254,
                16,
                2,
                0,
                26,
                11
            ]));
        } catch  {
            return !1;
        }
    }, Lt = ()=>{
        try {
            return WebAssembly.validate(new Uint8Array([
                0,
                97,
                115,
                109,
                1,
                0,
                0,
                0,
                1,
                4,
                1,
                96,
                0,
                0,
                3,
                2,
                1,
                0,
                10,
                30,
                1,
                28,
                0,
                65,
                0,
                253,
                15,
                253,
                12,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                253,
                186,
                1,
                26,
                11
            ]));
        } catch  {
            return !1;
        }
    }, Ae = async (e)=>{
        if (de) return Promise.resolve();
        if (ee) throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
        if (_e) throw new Error("previous call to 'initializeWebAssembly()' failed.");
        ee = !0;
        let t = e.initTimeout, n = e.numThreads;
        if (!Lt()) throw new Error("WebAssembly SIMD is not supported in the current environment.");
        let s = Tt();
        n > 1 && !s && (typeof self < "u" && !self.crossOriginIsolated && console.warn("env.wasm.numThreads is set to " + n + ", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."), console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."), e.numThreads = n = 1);
        let r = e.wasmPaths, i = typeof r == "string" ? r : void 0, o = r?.mjs, a = o?.href ?? o, c = r?.wasm, d = c?.href ?? c, w = e.wasmBinary, [l, u] = await Ie(a, i, n > 1), b = !1, v = [];
        if (t > 0 && v.push(new Promise((f)=>{
            setTimeout(()=>{
                b = !0, f();
            }, t);
        })), v.push(new Promise((f, y)=>{
            let P = {
                numThreads: n
            };
            if (w) P.wasmBinary = w;
            else if (d || i) P.locateFile = (p)=>d ?? i + p;
            else if (a && a.indexOf("blob:") !== 0) P.locateFile = (p)=>new URL(p, a).href;
            else if (l) {
                let p = xe();
                p && (P.locateFile = (h)=>p + h);
            }
            u(P).then((p)=>{
                ee = !1, de = !0, fe = p, f(), l && URL.revokeObjectURL(l);
            }, (p)=>{
                ee = !1, _e = !0, y(p);
            });
        })), await Promise.race(v), b) throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`);
    }, S = ()=>{
        if (de && fe) return fe;
        throw new Error("WebAssembly is not initialized yet.");
    };
});
var E, G, g, te = A(()=>{
    "use strict";
    j();
    E = (e, t)=>{
        let n = S(), s = n.lengthBytesUTF8(e) + 1, r = n._malloc(s);
        return n.stringToUTF8(e, r, s), t.push(r), r;
    }, G = (e, t, n, s)=>{
        if (typeof e == "object" && e !== null) {
            if (n.has(e)) throw new Error("Circular reference in options");
            n.add(e);
        }
        Object.entries(e).forEach(([r, i])=>{
            let o = t ? t + r : r;
            if (typeof i == "object") G(i, o + ".", n, s);
            else if (typeof i == "string" || typeof i == "number") s(o, i.toString());
            else if (typeof i == "boolean") s(o, i ? "1" : "0");
            else throw new Error(`Can't handle extra config type: ${typeof i}`);
        });
    }, g = (e)=>{
        let t = S(), n = t.stackSave();
        try {
            let s = t.PTR_SIZE, r = t.stackAlloc(2 * s);
            t._OrtGetLastError(r, r + s);
            let i = Number(t.getValue(r, s === 4 ? "i32" : "i64")), o = t.getValue(r + s, "*"), a = o ? t.UTF8ToString(o) : "";
            throw new Error(`${e} ERROR_CODE: ${i}, ERROR_MESSAGE: ${a}`);
        } finally{
            t.stackRestore(n);
        }
    };
});
var Ce, Be = A(()=>{
    "use strict";
    j();
    te();
    Ce = (e)=>{
        let t = S(), n = 0, s = [], r = e || {};
        try {
            if (e?.logSeverityLevel === void 0) r.logSeverityLevel = 2;
            else if (typeof e.logSeverityLevel != "number" || !Number.isInteger(e.logSeverityLevel) || e.logSeverityLevel < 0 || e.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);
            if (e?.logVerbosityLevel === void 0) r.logVerbosityLevel = 0;
            else if (typeof e.logVerbosityLevel != "number" || !Number.isInteger(e.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);
            e?.terminate === void 0 && (r.terminate = !1);
            let i = 0;
            return e?.tag !== void 0 && (i = E(e.tag, s)), n = t._OrtCreateRunOptions(r.logSeverityLevel, r.logVerbosityLevel, !!r.terminate, i), n === 0 && g("Can't create run options."), e?.extra !== void 0 && G(e.extra, "", new WeakSet, (o, a)=>{
                let c = E(o, s), d = E(a, s);
                t._OrtAddRunConfigEntry(n, c, d) !== 0 && g(`Can't set a run config entry: ${o} - ${a}.`);
            }), [
                n,
                s
            ];
        } catch (i) {
            throw n !== 0 && t._OrtReleaseRunOptions(n), s.forEach((o)=>t._free(o)), i;
        }
    };
});
var Pt, xt, It, _t, Me, Ue = A(()=>{
    "use strict";
    j();
    te();
    Pt = (e)=>{
        switch(e){
            case "disabled":
                return 0;
            case "basic":
                return 1;
            case "extended":
                return 2;
            case "all":
                return 99;
            default:
                throw new Error(`unsupported graph optimization level: ${e}`);
        }
    }, xt = (e)=>{
        switch(e){
            case "sequential":
                return 0;
            case "parallel":
                return 1;
            default:
                throw new Error(`unsupported execution mode: ${e}`);
        }
    }, It = (e)=>{
        e.extra || (e.extra = {}), e.extra.session || (e.extra.session = {});
        let t = e.extra.session;
        t.use_ort_model_bytes_directly || (t.use_ort_model_bytes_directly = "1"), e.executionProviders && e.executionProviders.some((n)=>(typeof n == "string" ? n : n.name) === "webgpu") && (e.enableMemPattern = !1);
    }, _t = (e, t, n)=>{
        for (let s of t){
            let r = typeof s == "string" ? s : s.name;
            switch(r){
                case "webnn":
                    if (r = "WEBNN", typeof s != "string") {
                        let a = s?.deviceType;
                        if (a) {
                            let c = E("deviceType", n), d = E(a, n);
                            S()._OrtAddSessionConfigEntry(e, c, d) !== 0 && g(`Can't set a session config entry: 'deviceType' - ${a}.`);
                        }
                    }
                    break;
                case "webgpu":
                    if (r = "JS", typeof s != "string") {
                        let o = s;
                        if (o?.preferredLayout) {
                            if (o.preferredLayout !== "NCHW" && o.preferredLayout !== "NHWC") throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${o.preferredLayout}`);
                            let a = E("preferredLayout", n), c = E(o.preferredLayout, n);
                            S()._OrtAddSessionConfigEntry(e, a, c) !== 0 && g(`Can't set a session config entry: 'preferredLayout' - ${o.preferredLayout}.`);
                        }
                    }
                    break;
                case "wasm":
                case "cpu":
                    continue;
                default:
                    throw new Error(`not supported execution provider: ${r}`);
            }
            let i = E(r, n);
            S()._OrtAppendExecutionProvider(e, i) !== 0 && g(`Can't append execution provider: ${r}.`);
        }
    }, Me = (e)=>{
        let t = S(), n = 0, s = [], r = e || {};
        It(r);
        try {
            let i = Pt(r.graphOptimizationLevel ?? "all"), o = xt(r.executionMode ?? "sequential"), a = typeof r.logId == "string" ? E(r.logId, s) : 0, c = r.logSeverityLevel ?? 2;
            if (!Number.isInteger(c) || c < 0 || c > 4) throw new Error(`log serverity level is not valid: ${c}`);
            let d = r.logVerbosityLevel ?? 0;
            if (!Number.isInteger(d) || d < 0 || d > 4) throw new Error(`log verbosity level is not valid: ${d}`);
            let w = typeof r.optimizedModelFilePath == "string" ? E(r.optimizedModelFilePath, s) : 0;
            if (n = t._OrtCreateSessionOptions(i, !!r.enableCpuMemArena, !!r.enableMemPattern, o, !!r.enableProfiling, 0, a, c, d, w), n === 0 && g("Can't create session options."), r.executionProviders && _t(n, r.executionProviders, s), r.enableGraphCapture !== void 0) {
                if (typeof r.enableGraphCapture != "boolean") throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);
                let l = E("enableGraphCapture", s), u = E(r.enableGraphCapture.toString(), s);
                t._OrtAddSessionConfigEntry(n, l, u) !== 0 && g(`Can't set a session config entry: 'enableGraphCapture' - ${r.enableGraphCapture}.`);
            }
            if (r.freeDimensionOverrides) for (let [l, u] of Object.entries(r.freeDimensionOverrides)){
                if (typeof l != "string") throw new Error(`free dimension override name must be a string: ${l}`);
                if (typeof u != "number" || !Number.isInteger(u) || u < 0) throw new Error(`free dimension override value must be a non-negative integer: ${u}`);
                let b = E(l, s);
                t._OrtAddFreeDimensionOverride(n, b, u) !== 0 && g(`Can't set a free dimension override: ${l} - ${u}.`);
            }
            return r.extra !== void 0 && G(r.extra, "", new WeakSet, (l, u)=>{
                let b = E(l, s), v = E(u, s);
                t._OrtAddSessionConfigEntry(n, b, v) !== 0 && g(`Can't set a session config entry: ${l} - ${u}.`);
            }), [
                n,
                s
            ];
        } catch (i) {
            throw n !== 0 && t._OrtReleaseSessionOptions(n) !== 0 && g("Can't release session options."), s.forEach((o)=>t._free(o)), i;
        }
    };
});
var H, ke, V, De, We, re, ne, Fe, pe = A(()=>{
    "use strict";
    H = (e)=>{
        switch(e){
            case "int8":
                return 3;
            case "uint8":
                return 2;
            case "bool":
                return 9;
            case "int16":
                return 5;
            case "uint16":
                return 4;
            case "int32":
                return 6;
            case "uint32":
                return 12;
            case "float16":
                return 10;
            case "float32":
                return 1;
            case "float64":
                return 11;
            case "string":
                return 8;
            case "int64":
                return 7;
            case "uint64":
                return 13;
            case "int4":
                return 22;
            case "uint4":
                return 21;
            default:
                throw new Error(`unsupported data type: ${e}`);
        }
    }, ke = (e)=>{
        switch(e){
            case 3:
                return "int8";
            case 2:
                return "uint8";
            case 9:
                return "bool";
            case 5:
                return "int16";
            case 4:
                return "uint16";
            case 6:
                return "int32";
            case 12:
                return "uint32";
            case 10:
                return "float16";
            case 1:
                return "float32";
            case 11:
                return "float64";
            case 8:
                return "string";
            case 7:
                return "int64";
            case 13:
                return "uint64";
            case 22:
                return "int4";
            case 21:
                return "uint4";
            default:
                throw new Error(`unsupported data type: ${e}`);
        }
    }, V = (e, t)=>{
        let n = [
            -1,
            4,
            1,
            1,
            2,
            2,
            4,
            8,
            -1,
            1,
            2,
            8,
            4,
            8,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            .5,
            .5
        ][e], s = typeof t == "number" ? t : t.reduce((r, i)=>r * i, 1);
        return n > 0 ? Math.ceil(s * n) : void 0;
    }, De = (e)=>{
        switch(e){
            case "float16":
                return typeof Float16Array < "u" && Float16Array.from ? Float16Array : Uint16Array;
            case "float32":
                return Float32Array;
            case "uint8":
                return Uint8Array;
            case "int8":
                return Int8Array;
            case "uint16":
                return Uint16Array;
            case "int16":
                return Int16Array;
            case "int32":
                return Int32Array;
            case "bool":
                return Uint8Array;
            case "float64":
                return Float64Array;
            case "uint32":
                return Uint32Array;
            case "int64":
                return BigInt64Array;
            case "uint64":
                return BigUint64Array;
            default:
                throw new Error(`unsupported type: ${e}`);
        }
    }, We = (e)=>{
        switch(e){
            case "verbose":
                return 0;
            case "info":
                return 1;
            case "warning":
                return 2;
            case "error":
                return 3;
            case "fatal":
                return 4;
            default:
                throw new Error(`unsupported logging level: ${e}`);
        }
    }, re = (e)=>e === "float32" || e === "float16" || e === "int32" || e === "int64" || e === "uint32" || e === "uint8" || e === "bool" || e === "uint4" || e === "int4", ne = (e)=>e === "float32" || e === "float16" || e === "int32" || e === "int64" || e === "uint32" || e === "uint64" || e === "int8" || e === "uint8" || e === "bool" || e === "uint4" || e === "int4", Fe = (e)=>{
        switch(e){
            case "none":
                return 0;
            case "cpu":
                return 1;
            case "cpu-pinned":
                return 2;
            case "texture":
                return 3;
            case "gpu-buffer":
                return 4;
            case "ml-tensor":
                return 5;
            default:
                throw new Error(`unsupported data location: ${e}`);
        }
    };
});
var q, me = A(()=>{
    "use strict";
    Q();
    q = async (e)=>{
        if (typeof e == "string") if (U) try {
            let { readFile: t } = ce("node:fs/promises");
            return new Uint8Array(await t(e));
        } catch (t) {
            if (t.code === "ERR_FS_FILE_TOO_LARGE") {
                let { createReadStream: n } = ce("node:fs"), s = n(e), r = [];
                for await (let i of s)r.push(i);
                return new Uint8Array(Buffer.concat(r));
            }
            throw t;
        }
        else {
            let t = await fetch(e);
            if (!t.ok) throw new Error(`failed to load external data file: ${e}`);
            let n = t.headers.get("Content-Length"), s = n ? parseInt(n, 10) : 0;
            if (s < 1073741824) return new Uint8Array(await t.arrayBuffer());
            {
                if (!t.body) throw new Error(`failed to load external data file: ${e}, no response body.`);
                let r = t.body.getReader(), i;
                try {
                    i = new ArrayBuffer(s);
                } catch (a) {
                    if (a instanceof RangeError) {
                        let c = Math.ceil(s / 65536);
                        i = new WebAssembly.Memory({
                            initial: c,
                            maximum: c
                        }).buffer;
                    } else throw a;
                }
                let o = 0;
                for(;;){
                    let { done: a, value: c } = await r.read();
                    if (a) break;
                    let d = c.byteLength;
                    new Uint8Array(i, o, d).set(c), o += d;
                }
                return new Uint8Array(i, 0, s);
            }
        }
        else return e instanceof Blob ? new Uint8Array(await e.arrayBuffer()) : e instanceof Uint8Array ? e : new Uint8Array(e);
    };
});
var At, Ne, je, $, Ct, ge, $e, ze, Re, Ge, He, Ve = A(()=>{
    "use strict";
    Be();
    Ue();
    pe();
    j();
    te();
    me();
    At = (e, t)=>{
        S()._OrtInit(e, t) !== 0 && g("Can't initialize onnxruntime.");
    }, Ne = async (e)=>{
        At(e.wasm.numThreads, We(e.logLevel));
    }, je = async (e, t)=>{}, $ = new Map, Ct = (e)=>{
        let t = S(), n = t.stackSave();
        try {
            let s = t.PTR_SIZE, r = t.stackAlloc(2 * s);
            t._OrtGetInputOutputCount(e, r, r + s) !== 0 && g("Can't get session input/output count.");
            let o = s === 4 ? "i32" : "i64";
            return [
                Number(t.getValue(r, o)),
                Number(t.getValue(r + s, o))
            ];
        } finally{
            t.stackRestore(n);
        }
    }, ge = (e)=>{
        let t = S(), n = t._malloc(e.byteLength);
        if (n === 0) throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);
        return t.HEAPU8.set(e, n), [
            n,
            e.byteLength
        ];
    }, $e = async (e, t)=>{
        let n, s, r = S();
        Array.isArray(e) ? [n, s] = e : e.buffer === r.HEAPU8.buffer ? [n, s] = [
            e.byteOffset,
            e.byteLength
        ] : [n, s] = ge(e);
        let i = 0, o = 0, a = 0, c = [], d = [], w = [];
        try {
            if ([o, c] = Me(t), t?.externalData && r.mountExternalData) {
                let p = [];
                for (let h of t.externalData){
                    let x = typeof h == "string" ? h : h.path;
                    p.push(q(typeof h == "string" ? h : h.data).then((M)=>{
                        r.mountExternalData(x, M);
                    }));
                }
                await Promise.all(p);
            }
            for (let p of t?.executionProviders ?? [])if ((typeof p == "string" ? p : p.name) === "webnn") {
                if (r.shouldTransferToMLTensor = !1, typeof p != "string") {
                    let x = p, M = x?.context, J = x?.gpuDevice, Y = x?.deviceType, X = x?.powerPreference;
                    M ? r.currentContext = M : J ? r.currentContext = await r.jsepCreateMLContext(J) : r.currentContext = await r.jsepCreateMLContext({
                        deviceType: Y,
                        powerPreference: X
                    });
                } else r.currentContext = await r.jsepCreateMLContext();
                break;
            }
            i = await r._OrtCreateSession(n, s, o), i === 0 && g("Can't create a session."), r.jsepOnCreateSession?.(), r.currentContext && (r.jsepRegisterMLContext(i, r.currentContext), r.currentContext = void 0, r.shouldTransferToMLTensor = !0);
            let [l, u] = Ct(i), b = !!t?.enableGraphCapture, v = [], f = [], y = [];
            for(let p = 0; p < l; p++){
                let h = r._OrtGetInputName(i, p);
                h === 0 && g("Can't get an input name."), d.push(h), v.push(r.UTF8ToString(h));
            }
            for(let p = 0; p < u; p++){
                let h = r._OrtGetOutputName(i, p);
                h === 0 && g("Can't get an output name."), w.push(h);
                let x = r.UTF8ToString(h);
                f.push(x);
            }
            let P = null;
            return $.set(i, [
                i,
                d,
                w,
                P,
                b,
                !1
            ]), [
                i,
                v,
                f
            ];
        } catch (l) {
            throw d.forEach((u)=>r._OrtFree(u)), w.forEach((u)=>r._OrtFree(u)), a !== 0 && r._OrtReleaseBinding(a) !== 0 && g("Can't release IO binding."), i !== 0 && r._OrtReleaseSession(i) !== 0 && g("Can't release session."), l;
        } finally{
            r._free(n), o !== 0 && r._OrtReleaseSessionOptions(o) !== 0 && g("Can't release session options."), c.forEach((l)=>r._free(l)), r.unmountExternalData?.();
        }
    }, ze = (e)=>{
        let t = S(), n = $.get(e);
        if (!n) throw new Error(`cannot release session. invalid session id: ${e}`);
        let [s, r, i, o, a] = n;
        o && (a && t._OrtClearBoundOutputs(o.handle) !== 0 && g("Can't clear bound outputs."), t._OrtReleaseBinding(o.handle) !== 0 && g("Can't release IO binding.")), t.jsepOnReleaseSession?.(e), r.forEach((c)=>t._OrtFree(c)), i.forEach((c)=>t._OrtFree(c)), t._OrtReleaseSession(s) !== 0 && g("Can't release session."), $.delete(e);
    }, Re = (e, t, n, s, r, i = !1)=>{
        if (!e) {
            t.push(0);
            return;
        }
        let o = S(), a = o.PTR_SIZE, c = e[0], d = e[1], w = e[3], l, u;
        if (c === "string" && (w === "gpu-buffer" || w === "ml-tensor")) throw new Error("String tensor is not supported on GPU.");
        if (i && w !== "gpu-buffer") throw new Error(`External buffer must be provided for input/output index ${r} when enableGraphCapture is true.`);
        if (w === "gpu-buffer") {
            let f = e[2].gpuBuffer;
            u = V(H(c), d);
            let y = o.jsepRegisterBuffer;
            if (!y) throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');
            l = y(s, r, f, u);
        } else if (w === "ml-tensor") {
            let f = e[2].mlTensor;
            u = V(H(c), d);
            let y = o.jsepRegisterMLTensor;
            if (!y) throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');
            l = y(f, H(c), d);
        } else {
            let f = e[2];
            if (Array.isArray(f)) {
                u = a * f.length, l = o._malloc(u), n.push(l);
                for(let y = 0; y < f.length; y++){
                    if (typeof f[y] != "string") throw new TypeError(`tensor data at index ${y} is not a string`);
                    o.setValue(l + y * a, E(f[y], n), "*");
                }
            } else u = f.byteLength, l = o._malloc(u), n.push(l), o.HEAPU8.set(new Uint8Array(f.buffer, f.byteOffset, u), l);
        }
        let b = o.stackSave(), v = o.stackAlloc(4 * d.length);
        try {
            d.forEach((y, P)=>o.setValue(v + P * a, y, a === 4 ? "i32" : "i64"));
            let f = o._OrtCreateTensor(H(c), l, u, v, d.length, Fe(w));
            f === 0 && g(`Can't create tensor for input/output. session=${s}, index=${r}.`), t.push(f);
        } finally{
            o.stackRestore(b);
        }
    }, Ge = async (e, t, n, s, r, i)=>{
        let o = S(), a = o.PTR_SIZE, c = $.get(e);
        if (!c) throw new Error(`cannot run inference. invalid session id: ${e}`);
        let d = c[0], w = c[1], l = c[2], u = c[3], b = c[4], v = c[5], f = t.length, y = s.length, P = 0, p = [], h = [], x = [], M = [], J = o.stackSave(), Y = o.stackAlloc(f * a), X = o.stackAlloc(f * a), ie = o.stackAlloc(y * a), Se = o.stackAlloc(y * a);
        try {
            o.jsepOnRunStart?.(d), [P, p] = Ce(i);
            for(let m = 0; m < f; m++)Re(n[m], h, M, e, t[m], b);
            for(let m = 0; m < y; m++)Re(r[m], x, M, e, f + s[m], b);
            for(let m = 0; m < f; m++)o.setValue(Y + m * a, h[m], "*"), o.setValue(X + m * a, w[t[m]], "*");
            for(let m = 0; m < y; m++)o.setValue(ie + m * a, x[m], "*"), o.setValue(Se + m * a, l[s[m]], "*");
            let C;
            C = await o._OrtRun(d, X, Y, f, Se, y, ie, P), C !== 0 && g("failed to call OrtRun().");
            let R = [];
            for(let m = 0; m < y; m++){
                let N = Number(o.getValue(ie + m * a, "*"));
                if (N === x[m]) {
                    R.push(r[m]);
                    continue;
                }
                let Ee = o.stackSave(), B = o.stackAlloc(4 * a), z = !1, T, I = 0;
                try {
                    o._OrtGetTensorData(N, B, B + a, B + 2 * a, B + 3 * a) !== 0 && g(`Can't access output tensor data on index ${m}.`);
                    let ae = a === 4 ? "i32" : "i64", Z = Number(o.getValue(B, ae));
                    I = o.getValue(B + a, "*");
                    let Oe = o.getValue(B + a * 2, "*"), lt = Number(o.getValue(B + a * 3, ae)), D = [];
                    for(let L = 0; L < lt; L++)D.push(Number(o.getValue(Oe + L * a, ae)));
                    o._OrtFree(Oe) !== 0 && g("Can't free memory for tensor dims.");
                    let W = D.reduce((L, O)=>L * O, 1);
                    T = ke(Z);
                    let K = u?.outputPreferredLocations[s[m]];
                    if (T === "string") {
                        if (K === "gpu-buffer" || K === "ml-tensor") throw new Error("String tensor is not supported on GPU.");
                        let L = [];
                        for(let O = 0; O < W; O++){
                            let F = o.getValue(I + O * a, "*"), ft = o.getValue(I + (O + 1) * a, "*"), dt = O === W - 1 ? void 0 : ft - F;
                            L.push(o.UTF8ToString(F, dt));
                        }
                        R.push([
                            T,
                            D,
                            L,
                            "cpu"
                        ]);
                    } else if (K === "gpu-buffer" && W > 0) {
                        let L = o.jsepGetBuffer;
                        if (!L) throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');
                        let O = L(I), F = V(Z, W);
                        if (F === void 0 || !re(T)) throw new Error(`Unsupported data type: ${T}`);
                        z = !0, R.push([
                            T,
                            D,
                            {
                                gpuBuffer: O,
                                download: o.jsepCreateDownloader(O, F, T),
                                dispose: ()=>{
                                    o._OrtReleaseTensor(N) !== 0 && g("Can't release tensor.");
                                }
                            },
                            "gpu-buffer"
                        ]);
                    } else if (K === "ml-tensor" && W > 0) {
                        let L = o.jsepEnsureTensor;
                        if (!L) throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');
                        if (V(Z, W) === void 0 || !ne(T)) throw new Error(`Unsupported data type: ${T}`);
                        let F = await L(I, Z, D, !1);
                        z = !0, R.push([
                            T,
                            D,
                            {
                                mlTensor: F,
                                download: o.jsepCreateMLTensorDownloader(I, T),
                                dispose: ()=>{
                                    o.jsepReleaseTensorId(I), o._OrtReleaseTensor(N);
                                }
                            },
                            "ml-tensor"
                        ]);
                    } else {
                        let L = De(T), O = new L(W);
                        new Uint8Array(O.buffer, O.byteOffset, O.byteLength).set(o.HEAPU8.subarray(I, I + O.byteLength)), R.push([
                            T,
                            D,
                            O,
                            "cpu"
                        ]);
                    }
                } finally{
                    o.stackRestore(Ee), T === "string" && I && o._free(I), z || o._OrtReleaseTensor(N);
                }
            }
            return u && !b && (o._OrtClearBoundOutputs(u.handle) !== 0 && g("Can't clear bound outputs."), $.set(e, [
                d,
                w,
                l,
                u,
                b,
                !1
            ])), R;
        } finally{
            o.stackRestore(J), h.forEach((C)=>o._OrtReleaseTensor(C)), x.forEach((C)=>o._OrtReleaseTensor(C)), M.forEach((C)=>o._free(C)), P !== 0 && o._OrtReleaseRunOptions(P), p.forEach((C)=>o._free(C));
        }
    }, He = (e)=>{
        let t = S(), n = $.get(e);
        if (!n) throw new Error("invalid session id");
        let s = n[0], r = t._OrtEndProfiling(s);
        r === 0 && g("Can't get an profile file name."), t._OrtFree(r);
    };
});
;
var be, qe, Je, Ye, Xe, Ze, Ke, Qe, et, tt, we = A(()=>{
    "use strict";
    Ve();
    j();
    le();
    be = !1, qe = !1, Je = !1, Ye = async ()=>{
        if (!qe) {
            if (be) throw new Error("multiple calls to 'initWasm()' detected.");
            if (Je) throw new Error("previous call to 'initWasm()' failed.");
            be = !0;
            try {
                await Ae(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm), await Ne(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"]), qe = !0;
            } catch (e) {
                throw Je = !0, e;
            } finally{
                be = !1;
            }
        }
    }, Xe = async (e)=>{
        await je(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"], e);
    }, Ze = async (e)=>ge(e), Ke = async (e, t)=>$e(e, t), Qe = async (e)=>{
        ze(e);
    }, et = async (e, t, n, s, r, i)=>Ge(e, t, n, s, r, i), tt = async (e)=>{
        He(e);
    };
});
;
var ot, Mt, oe, st = A(()=>{
    "use strict";
    we();
    pe();
    Q();
    me();
    ot = (e, t)=>{
        switch(e.location){
            case "cpu":
                return [
                    e.type,
                    e.dims,
                    e.data,
                    "cpu"
                ];
            case "gpu-buffer":
                return [
                    e.type,
                    e.dims,
                    {
                        gpuBuffer: e.gpuBuffer
                    },
                    "gpu-buffer"
                ];
            case "ml-tensor":
                return [
                    e.type,
                    e.dims,
                    {
                        mlTensor: e.mlTensor
                    },
                    "ml-tensor"
                ];
            default:
                throw new Error(`invalid data location: ${e.location} for ${t()}`);
        }
    }, Mt = (e)=>{
        switch(e[3]){
            case "cpu":
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"](e[0], e[2], e[1]);
            case "gpu-buffer":
                {
                    let t = e[0];
                    if (!re(t)) throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);
                    let { gpuBuffer: n, download: s, dispose: r } = e[2];
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"].fromGpuBuffer(n, {
                        dataType: t,
                        dims: e[1],
                        download: s,
                        dispose: r
                    });
                }
            case "ml-tensor":
                {
                    let t = e[0];
                    if (!ne(t)) throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);
                    let { mlTensor: n, download: s, dispose: r } = e[2];
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"].fromMLTensor(n, {
                        dataType: t,
                        dims: e[1],
                        download: s,
                        dispose: r
                    });
                }
            default:
                throw new Error(`invalid data location: ${e[3]}`);
        }
    }, oe = class {
        async fetchModelAndCopyToWasmMemory(t) {
            return Ze(await q(t));
        }
        async loadModel(t, n) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_BEGIN"])();
            let s;
            typeof t == "string" ? U ? s = await q(t) : s = await this.fetchModelAndCopyToWasmMemory(t) : s = t, [this.sessionId, this.inputNames, this.outputNames] = await Ke(s, n), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_END"])();
        }
        async dispose() {
            return Qe(this.sessionId);
        }
        async run(t, n, s) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_BEGIN"])();
            let r = [], i = [];
            Object.entries(t).forEach((u)=>{
                let b = u[0], v = u[1], f = this.inputNames.indexOf(b);
                if (f === -1) throw new Error(`invalid input '${b}'`);
                r.push(v), i.push(f);
            });
            let o = [], a = [];
            Object.entries(n).forEach((u)=>{
                let b = u[0], v = u[1], f = this.outputNames.indexOf(b);
                if (f === -1) throw new Error(`invalid output '${b}'`);
                o.push(v), a.push(f);
            });
            let c = r.map((u, b)=>ot(u, ()=>`input "${this.inputNames[i[b]]}"`)), d = o.map((u, b)=>u ? ot(u, ()=>`output "${this.outputNames[a[b]]}"`) : null), w = await et(this.sessionId, i, c, a, d, s), l = {};
            for(let u = 0; u < w.length; u++)l[this.outputNames[a[u]]] = o[u] ?? Mt(w[u]);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_END"])(), l;
        }
        startProfiling() {}
        endProfiling() {
            tt(this.sessionId);
        }
    };
});
var at = {};
bt(at, {
    OnnxruntimeWebAssemblyBackend: ()=>se,
    initializeFlags: ()=>it,
    wasmBackend: ()=>Ut
});
;
var it, se, Ut, ut = A(()=>{
    "use strict";
    we();
    st();
    it = ()=>{
        if ((typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.initTimeout != "number" || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.initTimeout < 0) && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.initTimeout = 0), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.simd === !1 && console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'), typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.proxy != "boolean" && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.proxy = !1), typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.trace != "boolean" && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.trace = !1), typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.numThreads != "number" || !Number.isInteger(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.numThreads) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.numThreads <= 0) if (typeof self < "u" && !self.crossOriginIsolated) __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.numThreads = 1;
        else {
            let e = typeof navigator > "u" ? ce("node:os").cpus().length : navigator.hardwareConcurrency;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.numThreads = Math.min(4, Math.ceil((e || 1) / 2));
        }
    }, se = class {
        async init(t) {
            it(), await Ye(), await Xe(t);
        }
        async createInferenceSessionHandler(t, n) {
            let s = new oe;
            return await s.loadModel(t, n), Promise.resolve(s);
        }
    }, Ut = new se;
});
;
;
;
var ve = "1.21.0-dev.20250206-d981b153d3";
var Cr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__;
{
    let e = (ut(), wt(at)).wasmBackend;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["registerBackend"])("cpu", e, 10), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["registerBackend"])("wasm", e, 10);
}Object.defineProperty(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].versions, "web", {
    value: ve,
    enumerable: !0
});
;
 //# sourceMappingURL=ort.node.min.mjs.map
}}),
"[project]/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs [app-ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$externals$5d2f$module__$5b$external$5d$__$28$module$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/module [external] (module, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$web$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$web$2f$dist$2f$ort$2e$node$2e$min$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs [app-ssr] (ecmascript) <locals>");
}}),
"[project]/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs [app-ssr] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "InferenceSession": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InferenceSession"]),
    "TRACE": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE"]),
    "TRACE_FUNC_BEGIN": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_BEGIN"]),
    "TRACE_FUNC_END": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_END"]),
    "Tensor": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]),
    "default": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$web$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$web$2f$dist$2f$ort$2e$node$2e$min$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"]),
    "env": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"]),
    "registerBackend": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["registerBackend"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$common$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$web$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$web$2f$dist$2f$ort$2e$node$2e$min$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs [app-ssr] (ecmascript) <locals>");
}}),
"[project]/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "InferenceSession": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$web$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$web$2f$dist$2f$ort$2e$node$2e$min$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["InferenceSession"]),
    "TRACE": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$web$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$web$2f$dist$2f$ort$2e$node$2e$min$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["TRACE"]),
    "TRACE_FUNC_BEGIN": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$web$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$web$2f$dist$2f$ort$2e$node$2e$min$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["TRACE_FUNC_BEGIN"]),
    "TRACE_FUNC_END": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$web$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$web$2f$dist$2f$ort$2e$node$2e$min$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["TRACE_FUNC_END"]),
    "Tensor": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$web$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$web$2f$dist$2f$ort$2e$node$2e$min$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["Tensor"]),
    "default": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$web$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$web$2f$dist$2f$ort$2e$node$2e$min$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["default"]),
    "env": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$web$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$web$2f$dist$2f$ort$2e$node$2e$min$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["env"]),
    "registerBackend": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$web$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$web$2f$dist$2f$ort$2e$node$2e$min$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["registerBackend"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$web$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$web$2f$dist$2f$ort$2e$node$2e$min$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$onnxruntime$2d$web$40$1$2e$21$2e$0$2d$dev$2e$20250206$2d$d981b153d3$2f$node_modules$2f$onnxruntime$2d$web$2f$dist$2f$ort$2e$node$2e$min$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs [app-ssr] (ecmascript) <exports>");
}}),

};

//# sourceMappingURL=node_modules__pnpm_45e4c05b._.js.map